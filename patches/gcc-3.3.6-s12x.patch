diff -rupN gcc-3.3.6/ChangeLog.M68HC11 gcc-3.3.6-s12x/ChangeLog.M68HC11
--- gcc-3.3.6/ChangeLog.M68HC11	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3.6-s12x/ChangeLog.M68HC11	2016-12-11 19:32:40.866702666 +0100
@@ -0,0 +1,4 @@
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* configure.in (m68hc11): Configure libstdcxx_version.
+
diff -rupN gcc-3.3.6/gcc/ChangeLog.M68HC11 gcc-3.3.6-s12x/gcc/ChangeLog.M68HC11
--- gcc-3.3.6/gcc/ChangeLog.M68HC11	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3.6-s12x/gcc/ChangeLog.M68HC11	2016-12-11 19:32:40.882702808 +0100
@@ -0,0 +1,384 @@
+2010-10-28 James Murray <jsm@jsm-net.demon.co.uk>
+    More work on 9s12x target building
+    S12X optimisations in larith.asm
+
+2010-10-26 James Murray <jsm@jsm-net.demon.co.uk>
+    Bump version
+    Include A.E.Smith S12X ldivmod.asm assembler long division
+    Port ldivmod.asm to S12
+    (Earlier work)
+    Support building as 9S12X target to match binutils
+
+2006-01-22  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 2006-01-22
+
+2006-01-22  Stephane Carrez  <stcarrez@nerim.fr>
+
+        PR savannah/13917
+	* config/m68hc11/m68hc11.c (nonimmediate_noinc_operand): New predicate.
+	* config/m68hc11/m68hc11-protos.h (nonimmediate_noinc_operand): Declare.
+	* config/m68hc11/m68hc11.h (PREDICATE_CODES): Register it.
+	* config/m68hc11/m68hc11.md ("addqi3"): Use it for operand 0, 1.
+	("uminqi3"): Likewise.
+	("umaxqi3"): Likewise.
+	("uminhi3"): Likewise.
+	("umaxhi3"): Likewise.
+	("negqi2"): Likewise.
+	("*ashlqi3_const1", "*ashrqi3_const1"): Likewise.
+	("lshrhi3_const", "*lshrqi3_const1"): Likewise.
+
+2006-01-20  Stephane Carrez  <stcarrez@nerim.fr>
+
+	savannah/15493
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movqi): Must save register
+	A and copy X or Y in it for a move when both operands refer to X or Y.
+
+2005-11-05  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/13879
+	* expmed.c (make_tree): If we have a constant for SIGN_EXTEND or
+	ZERO_EXTEND, use the mode from the extend node; the constant is VOIDmode
+	and it will crash.
+
+2005-11-05  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* expmed.c (store_bit_field): Must apply a correction for big-endian
+	target when the bitfield contains less word than the source constant.
+
+2005-05-15  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.h (REG_VALID_P): The macro can be used with
+	signed numbers passed as argument.
+	* version.c: Bump to 20050515
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/12572
+	* config/m68hc11/m68hc11.md ("movhi"): Sign extend the constants in
+	the range 32768..65535 so that the generated set is recognized.
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("mulqi3"): Use general_operand for operand
+	1 and fix constraints.
+	("mulqihi3")" Use general_operand for operand 2.
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movqi): Use pula and pulb
+	instead of lda and ldb for 68HC12.
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11-protos.h (m68hc11_hard_regno_rename_ok): Pass
+	the mode.
+	* config/m68hc11/m68hc11.h (HARD_REGNO_RENAME_OK): Likewise.
+	* config/m68hc11/m68hc11.c (m68hc11_hard_regno_rename_ok): Likewise.
+	* regrename.c (regrename_optimize): Pass the mode in which the register
+	is used.
+
+2005-04-03  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/12297
+	* config/m68hc11/m68hc11.c (m68hc11_z_replacement): Use emit_insn_after
+	when adding the save Z instruction so that it is part of the good BB.
+
+2005-02-13  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/17551
+	* gcse.c (handle_avail_expr): Use gen_move_insn() instead of
+	gen_rtx_SET()
+
+2005-02-13  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/16925
+	* config/m68hc11/m68hc11.c (m68hc11_gen_highpart): Handle split of
+	64-bit constants on 64-bit hosts.
+	(m68hc11_split_logical): Simplify.
+	(m68hc11_split_move): Likewise.
+
+2005-02-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/11813
+	* config/m68hc11/m68hc11.c (reg_or_some_mem_operand): Do not allow
+	the 68HC12 address indirect addressing mode as it is not supported
+	by bset and bclr.
+
+2005-01-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c (version_string): Bump to 2005-01-29.
+	* config/udivmodsi4.c (__udivmodsi4): Rewrite ediv as it didn't
+	passed the gcc validation.
+
+2005-01-28  Stephane Carrez  <stcarrez@nerim.fr>
+
+	From philipljohnson@comcast.net:
+
+	Patch savannah/3626
+	* config/udivmodsi4.c (__udivmodsi4): Use 68HC12 ediv instruction to
+	compute division and modulus.
+
+2004-08-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movhi): Fix invalid generation
+	of indexed indirect addressing with movw
+
+2004-08-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c (version_string): Bump to 2004-08-29.
+
+2004-08-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* final.c (alter_subreg): Adjust the offset of paradoxical subreg
+	so that we load the correct value.
+
+2004-08-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("movhi_const0"): Use this pattern only
+	for 68HC11.
+
+2004-08-01  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c (version_string): Bump to 2004-08-01 and use gcc 3.3.4.
+
+2004-06-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/14542
+	* config/m68hc11/m68hc11.md (move peephole2): Emit a use note to avoid
+	a live change of a register after peephole replacement.
+
+2004-06-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/14457
+	* config/m68hc11/m68hc11.c (splitable_operand): New predicate.
+	* config/m68hc11/m68hc11-protos.h (splitable_operand): Declare.
+	* config/m68hc11/m68hc11.h (PREDICATE_CODES): Register it.
+	(inhibit_libc): Must define.
+	* config/m68hc11/m68hc11.md ("movhi_const0"): Use splitable_operand.
+	("*andhi3_gen", "iorhi3", "*iorhi3_gen"): Likewise.
+	("xorhi3"): Likewise.
+
+2004-04-25  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("iorqi3_gen"): Use general_operand for
+	first operand.
+	("*andqi3_gen", "xorqi3"): Likewise.
+	("subqi3", "*subhi3"): Likewise.
+	("*addhi3_zext"): Likewise.
+
+2004-04-25  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.h (ASM_OUTPUT_LABELREF): Redefine to strip
+	any name encoding.
+
+2004-03-07  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*lshrsi3_const"): Disable for 68HC12.
+	("*lshrsi3"): Also accept an immediate for 68HC12.
+	("*ashrsi3_const"): Likewise.
+	("*ashrsi3"): Likewise.
+	("*ashlsi3_const"): Likewise.
+	("*ashlsi3"): Likewise.
+	("cmphi_1_hc12"): Compare two hard register by pushing them and
+	comparing with a pop; don't use a split for that.
+	("cmphi split"): Disable compare split for 68HC12.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*lshrsi3_const1"): Allow a memory for
+	operand 1 when operand 0 is a soft register.
+	("*ashlsi3_const1"): Likewise.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movhi): Use 2,-sp to push
+	the stack register.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* doc/extend.texi (Function Attributes): Document page0, trap and
+	update far documentation.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/4987:
+	* doc/invoke.texi (M68hc1x Options): Document -mrelax
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/8028:
+	* config/m68hc11/m68hc11.c (expand_prologue): Don't make an interrupt
+	or a trap handler a far symbol.
+	(m68hc11_initial_elimination_offset): Likewise.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*lshrsi3_const1"): Tune constraints
+	to optimize more case where we don't need a scratch register.
+	("*ashlsi3_const1"): Likewise.
+	("*pushdi_internal"): New insn and split
+	to separate push from moves.
+	("*pushdf_internal"): Likewise.
+	("*pushsf_internal"): Likewise.
+	("*pushsi_internal"): Likewise.
+	("movdi_internal"): Use define_insn_and_split; non push operand.
+	("movdf_internal"): Likewise.
+	("movsf_internal"): Likewise.
+	("movsi_internal"): Likewise.
+
+2004-03-02  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.c (m68hc11_addr_mode): New variable.
+	(m68hc11_mov_addr_mode): Likewise.
+	(m68hc11_override_options): Initialize them based on target.
+	(register_indirect_p): Allow a MEM for indirect addressing modes and
+	use flags to control what is allowed.
+	(m68hc11_small_indexed_indirect_p): Use m68hc11_mov_addr_mode for
+	supported addressing modes.
+	(m68hc11_register_indirect_p): Use m68hc11_addr_mode.
+	(go_if_legitimate_address_internal): Likewise.
+	(m68hc11_indirect_p): Likewise and check the mode.
+	(print_operand): Allow a (MEM (MEM)) and generate indirect addressing.
+
+2004-02-22  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20040222 and use gcc 3.3.3.
+
+2003-11-16  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 200311116.
+
+2003-11-10  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11-protos.h (m68hc11_page0_symbol_p): Declare.
+	* config/m68hc11/m68hc11.c (m68hc11_page0_symbol_p): New predicate.
+	(m68hc11_indirect_p): Use it.
+	(print_operand): Likewise.
+	(m68hc11_handle_page0_attribute): New function to handle page0
+	attribute
+	(m68hc11_attribute_table): New attribute page0
+	(m68hc11_encode_section_info): Check page0 attribute.
+	* config/m68hc11/m68hc11.md: Use define_insn_and_split
+	(peephole2): New peephole to generate bset/bclr.
+	(peephole): New peephole to optimize compare in few cases and
+	setting of 2 registers from memory.
+
+2003-10-04  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20031004.
+
+2003-10-04  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/3432:
+	* config/m68hc11/t-m68hc11-gas (MULTILIB_MATCHES): m68hcs12 is
+	identical to m68hc12 for libraries.
+
+2003-10-01  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20031001.
+
+2003-09-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*ashldi3_const32"): Adjust first operand
+	if it uses stack pointer register.
+
+2003-09-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (peephole2 "remove one load"): Make sure
+	that register operand 3 does not appear in operand 2.
+
+2003-08-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20030808
+
+2003-08-02  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (peephole2 "leas 2,sp"): Enable it
+	and add a use rtx.
+	(peephole2): New peephole to optimize moves on stack.
+
+2003-07-19  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (peephole2 abx): Use m68hc11_gen_lowpart
+	to make sure the constant has the appropriate QImode.
+
+2003-07-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.h (HAVE_AS_DWARF2_DEBUG_LINE): Don't define
+	as .file/.loc directives are incompatible with linker relaxation.
+
+2003-05-19  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*movqi" split): Don't split when source
+	or destination is d, b or a register.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*logicalhi3_zexthi_ashift8): Allow
+	address registers for operand 1 and 2.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* reload.c (find_reloads_toplev): Do not reload the paradoxical
+	subreg with its wider mode but the register itself.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	Merge 3.0.4-20030501 patchs in 3.3
+
+	2003-03-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md
+	("movdi_internal", "movdf_internal"): Fix constraints.
+	("movsi_internal", "movsf_internal"): Likewise.
+	(peephole2): New peephole2 to optimize the address computations
+	by using 'abx' and 'aby'.
+	(peephole2): New peephole2 to optimize 32-bit shift and use only
+	one hard register instead of two.
+	(peephole2): New peephole2 to avoid loading the same value in two
+	different registers.
+
+	2003-03-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (split "logicalsi3_silshl16_zext"): Split
+	after reload but reject the particular case that generates a xgdx 
+	pattern, it must be handled after Z register replacement.
+
+	2003-03-10  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*addhi3_68hc12"): Accept any constant
+	when adding to X and Y since leax/leay are fast.
+	("*addhi3"): Accept 'I' constraint when adding to address register.
+
+	2003-02-27  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*logicalsi3_silshr16"): Accept D reg
+	on all operands.
+
+	2003-01-10  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*logicalsi3_silshl16_zext"): New split.
+	("*logicalsi3_silshr16"): Fix constraints.
+
+	2002-02-27  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* reload.c (find_reloads): Change to RELOAD_FOR_OTHER_ADDRESS any
+	RELOAD_FOR_OPERAND_ADDRESS reloads which is used by a RELOAD_FOR_OTHER
+	reload (ensures correct order of reload insns).
+
+	2001-07-09  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* reload1.c (merge_assigned_reloads): After a RELOAD_OTHER merge,
+	fix setting of the reloads of that reload to RELOAD_FOR_OTHER_ADDRESS.
+
+	2001-06-22  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* config/m68hc11/m68hc11.h (MAX_BITS_PER_WORD): Define to 32.
+
+	2001-03-01  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* reload1.c (merge_assigned_reloads): Change the type of the
+	reload to emit it at the good place after the merge.
+
+	2001-02-24  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+        * reload.c (find_reloads_subreg_address): Call find_reloads_address
+        with the same reload type.
diff -rupN gcc-3.3.6/gcc/collect2.c gcc-3.3.6-s12x/gcc/collect2.c
--- gcc-3.3.6/gcc/collect2.c	2016-12-11 19:32:34.650647599 +0100
+++ gcc-3.3.6-s12x/gcc/collect2.c	2016-12-11 19:32:40.886702843 +0100
@@ -74,6 +74,10 @@ Software Foundation, 59 Temple Place - S
 #undef REAL_STRIP_FILE_NAME
 #endif
 
+#ifdef WIN32
+# define USE_POPEN
+#endif
+
 /* If we cannot use a special method, use the ordinary one:
    run nm to find what symbols are present.
    In a cross-compiler, this means you need a cross nm,
@@ -444,7 +448,11 @@ handler (signo)
 #endif
 
   signal (signo, SIG_DFL);
+#ifndef WIN32
   kill (getpid (), signo);
+#else
+  exit(3);
+#endif
 }
 
 
@@ -2081,6 +2089,31 @@ scan_prog_file (prog_name, which_pass)
   if (nm_file_name == 0)
     fatal ("cannot find `nm'");
 
+#ifdef USE_POPEN
+  p = (char*) xmalloc (strlen (nm_file_name)
+                       + strlen (NM_FLAGS)
+                       + strlen (prog_name)
+                       + 10);
+  strcpy (p, nm_file_name);
+  strcat (p, " ");
+  if (NM_FLAGS[0] != '\0')
+    {
+      strcat (p, NM_FLAGS);
+      strcat (p, " ");
+    }
+  strcat (p, prog_name);
+  inf = popen (p, "r");
+  if (inf == NULL)
+    fatal_perror ("can't popen `%s'", p);
+
+  /* Trace if needed.  */
+  if (vflag)
+    fprintf (stderr, " %s\n", p);
+
+  free (p);
+  fflush (stdout);
+  fflush (stderr);
+#else
   nm_argv[argc++] = nm_file_name;
   if (NM_FLAGS[0] != '\0')
     nm_argv[argc++] = NM_FLAGS;
@@ -2142,6 +2175,7 @@ scan_prog_file (prog_name, which_pass)
 
   if (debug)
     fprintf (stderr, "\nnm output with constructors/destructors.\n");
+#endif
 
   /* Read each line of nm output.  */
   while (fgets (buf, sizeof buf, inf) != (char *) 0)
@@ -2215,7 +2249,11 @@ scan_prog_file (prog_name, which_pass)
   if (fclose (inf) != 0)
     fatal_perror ("fclose");
 
+#ifdef USE_POPEN
+  pclose (inf);
+#else
   do_wait (nm_file_name);
+#endif
 
   signal (SIGINT,  int_handler);
 #ifdef SIGQUIT
diff -rupN gcc-3.3.6/gcc/combine.c gcc-3.3.6-s12x/gcc/combine.c
--- gcc-3.3.6/gcc/combine.c	2016-12-11 19:32:34.670647776 +0100
+++ gcc-3.3.6-s12x/gcc/combine.c	2016-12-11 19:32:40.894702914 +0100
@@ -6553,7 +6553,7 @@ make_compound_operation (x, in_code)
      address, we stay there.  If we have a comparison, set to COMPARE,
      but once inside, go back to our default of SET.  */
 
-  next_code = (code == MEM || code == PLUS || code == MINUS ? MEM
+  next_code = (code == MEM /* SCz: || code == PLUS || code == MINUS */ ? MEM
 	       : ((code == COMPARE || GET_RTX_CLASS (code) == '<')
 		  && XEXP (x, 1) == const0_rtx) ? COMPARE
 	       : in_code == COMPARE ? SET : in_code);
diff -rupN gcc-3.3.6/gcc/config/divmod.c gcc-3.3.6-s12x/gcc/config/divmod.c
--- gcc-3.3.6/gcc/config/divmod.c	2016-12-11 19:32:34.670647776 +0100
+++ gcc-3.3.6-s12x/gcc/config/divmod.c	2016-12-11 19:32:40.894702914 +0100
@@ -1,4 +1,21 @@
-long udivmodsi4 ();
+/* cover the root directory case */
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+#if defined(target11)
+#define mc68hc11
+#endif
+#if defined(target12)
+#define mc68hc12
+#endif
+#if defined(targets12x)
+#define m9s12x
+#define mc68hc12
+#endif
+#endif
+
+#ifndef mc68hc12
+
+extern unsigned long __udivmodsi4 (unsigned long num, unsigned long den,
+                                   unsigned long *mod);
 
 long
 __divsi3 (long a, long b)
@@ -18,7 +35,7 @@ __divsi3 (long a, long b)
       neg = !neg;
     }
 
-  res = udivmodsi4 (a, b, 0);
+  res = __udivmodsi4 (a, b, 0);
 
   if (neg)
     res = -res;
@@ -41,10 +58,13 @@ __modsi3 (long a, long b)
   if (b < 0)
     b = -b;
 
-  res = udivmodsi4 (a, b, 1);
+  __udivmodsi4 (a, b, (unsigned long*) &res);
 
   if (neg)
     res = -res;
 
   return res;
 }
+
+
+#endif /* !mc68hc12  */
diff -rupN gcc-3.3.6/gcc/config/larith.asm gcc-3.3.6-s12x/gcc/config/larith.asm
--- gcc-3.3.6/gcc/config/larith.asm	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3.6-s12x/gcc/config/larith.asm	2016-12-11 19:32:40.894702914 +0100
@@ -0,0 +1,1348 @@
+/* libgcc routines for M68HC11 & M68HC12.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+	.file "larith.asm"
+
+#ifdef __HAVE_SHORT_INT__
+	.mode mshort
+#else
+	.mode mlong
+#endif
+
+	.macro declare_near name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#if defined(__USE_RTC__)
+# define ARG(N) N+1
+
+	.macro ret
+#if defined(mc68hc12)
+	rtc
+#else
+	jmp __return_32
+#endif
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+	.far   \name
+\name:
+	.endm
+
+	.macro farsym name
+	.far NAME
+	.endm
+
+#else
+# define ARG(N) N
+
+	.macro ret
+	rts
+	.endm
+
+	.macro farsym name
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#endif
+
+	.sect .text
+	
+
+#define REG(NAME)			\
+NAME:	.dc.w	1;			\
+	.type NAME,@object ;		\
+	.size NAME,2
+
+#ifdef L_regs_min
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+
+	.sect .softregs
+	.globl _.tmp
+	.globl _.z,_.xy
+REG(_.tmp)
+REG(_.z)
+REG(_.xy)
+
+#endif
+
+#ifdef L_regs_frame
+	.sect .softregs
+	.globl _.frame
+REG(_.frame)
+#endif
+
+#ifdef L_regs_d1_2
+	.sect .softregs
+	.globl _.d1,_.d2
+REG(_.d1)
+REG(_.d2)
+#endif
+
+#ifdef L_regs_d3_4
+	.sect .softregs
+	.globl _.d3,_.d4
+REG(_.d3)
+REG(_.d4)
+#endif
+
+#ifdef L_regs_d5_6
+	.sect .softregs
+	.globl _.d5,_.d6
+REG(_.d5)
+REG(_.d6)
+#endif
+
+#ifdef L_regs_d7_8
+	.sect .softregs
+	.globl _.d7,_.d8
+REG(_.d7)
+REG(_.d8)
+#endif
+
+#ifdef L_regs_d9_16
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+	.sect .softregs
+	.globl _.d9,_.d10,_.d11,_.d12,_.d13,_.d14
+	.globl _.d15,_.d16
+REG(_.d9)
+REG(_.d10)
+REG(_.d11)
+REG(_.d12)
+REG(_.d13)
+REG(_.d14)
+REG(_.d15)
+REG(_.d16)
+
+#endif
+
+#ifdef L_regs_d17_32
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+	.sect .softregs
+	.globl _.d17,_.d18,_.d19,_.d20,_.d21,_.d22
+	.globl _.d23,_.d24,_.d25,_.d26,_.d27,_.d28
+	.globl _.d29,_.d30,_.d31,_.d32
+REG(_.d17)
+REG(_.d18)
+REG(_.d19)
+REG(_.d20)
+REG(_.d21)
+REG(_.d22)
+REG(_.d23)
+REG(_.d24)
+REG(_.d25)
+REG(_.d26)
+REG(_.d27)
+REG(_.d28)
+REG(_.d29)
+REG(_.d30)
+REG(_.d31)
+REG(_.d32)
+#endif
+
+#ifdef L_premain
+;;
+;; Specific initialization for 68hc11 before the main.
+;; Nothing special for a generic routine; Just enable interrupts.
+;;
+	declare_near	__premain
+	clra
+	tap	; Clear both I and X.
+	rts
+#endif
+
+#ifdef L__exit
+;;
+;; Exit operation.  Just loop forever and wait for interrupts.
+;; (no other place to go)
+;; This operation is split in several pieces collected together by
+;; the linker script.  This allows to support destructors at the
+;; exit stage while not impacting program sizes when there is no
+;; destructors.
+;;
+;; _exit:
+;;    *(.fini0)		/* Beginning of finish code (_exit symbol).  */
+;;    *(.fini1)		/* Place holder for applications.  */
+;;    *(.fini2)		/* C++ destructors.  */
+;;    *(.fini3)		/* Place holder for applications.  */
+;;    *(.fini4)		/* Runtime exit.  */
+;;
+	.sect .fini0,"ax",@progbits
+	.globl _exit
+	.globl exit
+	.weak  exit
+	farsym  exit
+	farsym  _exit
+exit:
+_exit:
+
+	.sect .fini4,"ax",@progbits
+fatal:
+	cli
+	wai
+	bra fatal
+#endif
+
+#ifdef L_abort
+;;
+;; Abort operation.  This is defined for the GCC testsuite.
+;;
+	declare	abort
+
+	ldd	#255		; 
+#ifdef mc68hc12
+	trap	#0x30
+#else
+	.byte 0xCD		; Generate an illegal instruction trap
+	.byte 0x03		; The simulator catches this and stops.
+#endif
+	jmp _exit
+#endif
+	
+#ifdef L_cleanup
+;;
+;; Cleanup operation used by exit().
+;;
+	declare	_cleanup
+
+	ret
+#endif
+
+;-----------------------------------------
+; required gcclib code
+;-----------------------------------------
+#ifdef L_memcpy
+       declare	memcpy
+       declare	__memcpy
+
+	.weak memcpy
+;;;
+;;; void* memcpy(void*, const void*, size_t)
+;;; 
+;;; D    = dst	Pmode
+;;; 2,sp = src	Pmode
+;;; 4,sp = size	HImode (size_t)
+;;; 
+#ifdef mc68hc12
+	ldx	ARG(2),sp
+	ldy	ARG(4),sp
+	pshd
+	xgdy
+	lsrd
+	bcc	Start
+	movb	1,x+,1,y+
+Start:
+	beq	Done
+Loop:
+	movw	2,x+,2,y+
+	dbne	d,Loop
+Done:
+	puld
+	ret
+#else
+	xgdy
+	tsx
+	ldd	ARG(4),x
+	ldx	ARG(2),x	; SRC = X, DST = Y
+	cpd	#0
+	beq	End
+	pshy
+	inca			; Correction for the deca below
+L0:
+	psha			; Save high-counter part
+L1:
+	ldaa	0,x		; Copy up to 256 bytes
+	staa	0,y
+	inx
+	iny
+	decb
+	bne	L1
+	pula
+	deca
+	bne	L0
+	puly			; Restore Y to return the DST
+End:
+	xgdy
+	ret
+#endif
+#endif
+
+#ifdef L_memset
+       declare	memset
+       declare	__memset
+;;;
+;;; void* memset(void*, int value, size_t)
+;;; 
+#ifndef __HAVE_SHORT_INT__
+;;; D    = dst	Pmode
+;;; 2,sp = src	SImode
+;;; 6,sp = size	HImode (size_t)
+	val  = ARG(5)
+	size = ARG(6)
+#else
+;;; D    = dst	Pmode
+;;; 2,sp = src	SImode
+;;; 6,sp = size	HImode (size_t)
+	val  = ARG(3)
+	size = ARG(4)
+#endif
+#ifdef mc68hc12
+	xgdx
+	ldab	val,sp
+	ldy	size,sp
+	pshx
+	beq	End
+Loop:
+	stab	1,x+
+	dbne	y,Loop
+End:
+	puld
+	ret
+#else
+	xgdx
+	tsy
+	ldab	val,y
+	ldy	size,y		; DST = X, CNT = Y
+	beq	End
+	pshx
+L0:
+	stab	0,x		; Fill up to 256 bytes
+	inx
+	dey
+	bne	L0
+	pulx			; Restore X to return the DST
+End:
+	xgdx
+	ret
+#endif
+#endif
+
+#ifdef L_adddi3
+	declare	___adddi3
+
+	tsx
+	xgdy
+	ldd	ARG(8),x		; Add LSB
+	addd	ARG(16),x
+	std	6,y		; Save (carry preserved)
+
+	ldd	ARG(6),x
+	adcb	ARG(15),x
+	adca	ARG(14),x
+	std	4,y
+
+	ldd	ARG(4),x
+	adcb	ARG(13),x
+	adca	ARG(12),x
+	std	2,y
+	
+	ldd	ARG(2),x
+	adcb	ARG(11),x		; Add MSB
+	adca	ARG(10),x
+	std	0,y
+
+	xgdy
+	ret
+#endif
+
+#ifdef L_subdi3
+	declare	___subdi3
+
+	tsx
+	xgdy
+	ldd	ARG(8),x		; Subtract LSB
+	subd	ARG(16),x
+	std	6,y			; Save, borrow preserved
+
+	ldd	ARG(6),x
+	sbcb	ARG(15),x
+	sbca	ARG(14),x
+	std	4,y
+
+	ldd	ARG(4),x
+	sbcb	ARG(13),x
+	sbca	ARG(12),x
+	std	2,y
+	
+	ldd	ARG(2),x		; Subtract MSB
+	sbcb	ARG(11),x
+	sbca	ARG(10),x
+	std	0,y
+
+	xgdy			;
+	ret
+#endif
+	
+#ifdef L_notdi2
+	declare	___notdi2
+
+	tsy
+	xgdx
+	ldd	ARG(8),y
+	coma
+	comb
+	std	6,x
+	
+	ldd	ARG(6),y
+	coma
+	comb
+	std	4,x
+
+	ldd	ARG(4),y
+	coma
+	comb
+	std	2,x
+
+	ldd	ARG(2),y
+	coma
+	comb
+	std	0,x
+	xgdx
+	ret
+#endif
+	
+#ifdef L_negsi2
+	declare_near ___negsi2
+
+	comb
+	coma
+	xgdx
+	comb
+	coma
+	inx
+	xgdx
+	bne	done
+	inx
+done:
+	rts
+#endif
+
+#ifdef L_one_cmplsi2
+	declare_near ___one_cmplsi2
+
+	comb
+	coma
+	xgdx
+	comb
+	coma
+	xgdx
+	rts
+#endif
+	
+#ifdef L_ashlsi3
+	declare_near ___ashlsi3
+
+	xgdy
+	clra
+	andb	#0x1f
+	xgdy
+	beq	Return
+Loop:
+	lsld
+	xgdx
+	rolb
+	rola
+	xgdx
+	dey
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_ashrsi3
+	declare_near ___ashrsi3
+
+	xgdy
+	clra
+	andb	#0x1f
+	xgdy
+	beq	Return
+Loop:
+	xgdx
+	asra
+	rorb
+	xgdx
+	rora
+	rorb
+	dey
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_lshrsi3
+	declare_near ___lshrsi3
+
+	xgdy
+	clra
+	andb	#0x1f
+	xgdy
+	beq	Return
+Loop:
+	xgdx
+	lsrd
+	xgdx
+	rora
+	rorb
+	dey
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_lshrhi3
+	declare_near ___lshrhi3
+
+	cpx	#16
+	bge	Return_zero
+	cpx	#0
+	beq	Return
+Loop:
+	lsrd
+	dex
+	bne	Loop
+Return:
+	rts
+Return_zero:
+	clra
+	clrb
+	rts
+#endif
+	
+#ifdef L_lshlhi3
+	declare_near ___lshlhi3
+
+	cpx	#16
+	bge	Return_zero
+	cpx	#0
+	beq	Return
+Loop:
+	lsld
+	dex
+	bne	Loop
+Return:
+	rts
+Return_zero:
+	clra
+	clrb
+	rts
+#endif
+
+#ifdef L_rotrhi3
+	declare_near ___rotrhi3
+
+___rotrhi3:
+	xgdx
+	clra
+	andb	#0x0f
+	xgdx
+	beq	Return
+Loop:
+	tap
+	rorb
+	rora
+	dex
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_rotlhi3
+	declare_near ___rotlhi3
+
+___rotlhi3:
+	xgdx
+	clra
+	andb	#0x0f
+	xgdx
+	beq	Return
+Loop:
+	asrb
+	rolb
+	rola
+	rolb
+	dex
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_ashrhi3
+	declare_near ___ashrhi3
+
+	cpx	#16
+	bge	Return_minus_1_or_zero
+	cpx	#0
+	beq	Return
+Loop:
+	asra
+	rorb
+	dex
+	bne	Loop
+Return:
+	rts
+Return_minus_1_or_zero:
+	clrb
+	tsta
+	bpl	Return_zero
+	comb
+Return_zero:
+	tba
+	rts
+#endif
+	
+#ifdef L_ashrqi3
+	declare_near ___ashrqi3
+
+	cmpa	#8
+	bge	Return_minus_1_or_zero
+	tsta
+	beq	Return
+Loop:
+	asrb
+	deca
+	bne	Loop
+Return:
+	rts
+Return_minus_1_or_zero:
+	clrb
+	tstb
+	bpl	Return_zero
+	coma
+Return_zero:
+	tab
+	rts
+#endif
+
+#ifdef L_lshlqi3
+	declare_near ___lshlqi3
+
+	cmpa	#8
+	bge	Return_zero
+	tsta
+	beq	Return
+Loop:
+	lslb
+	deca
+	bne	Loop
+Return:
+	rts
+Return_zero:
+	clrb
+	rts
+#endif
+
+#ifdef L_divmodhi4
+#ifndef mc68hc12
+/* 68HC12 signed divisions are generated inline (idivs).  */
+
+	declare_near __divmodhi4
+
+;
+;; D = numerator
+;; X = denominator
+;;
+;; Result:	D = D / X
+;;		X = D % X
+;; 
+	tsta
+	bpl	Numerator_pos
+	comb			; D = -D <=> D = (~D) + 1
+	coma
+	xgdx
+	inx
+	tsta
+	bpl	Numerator_neg_denominator_pos
+Numerator_neg_denominator_neg:
+	comb			; X = -X
+	coma
+	addd	#1
+	xgdx
+	idiv
+	coma
+	comb
+	xgdx			; Remainder <= 0 and result >= 0
+	inx
+	rts
+
+Numerator_pos_denominator_pos:
+	xgdx
+	idiv
+	xgdx			; Both values are >= 0
+	rts
+	
+Numerator_pos:
+	xgdx
+	tsta
+	bpl	Numerator_pos_denominator_pos
+Numerator_pos_denominator_neg:
+	coma			; X = -X
+	comb
+	xgdx
+	inx
+	idiv
+	xgdx			; Remainder >= 0 but result <= 0
+	coma
+	comb
+	addd	#1
+	rts
+	
+Numerator_neg_denominator_pos:
+	xgdx
+	idiv
+	coma			; One value is > 0 and the other < 0
+	comb			; Change the sign of result and remainder
+	xgdx
+	inx
+	coma
+	comb
+	addd	#1
+	rts
+#endif /* !mc68hc12 */
+#endif
+
+#ifdef L_mulqi3
+	declare_near ___mulqi3
+
+;
+; short __mulqi3(signed char a, signed char b);
+;
+;	signed char a	-> register A
+;	signed char b	-> register B
+;
+; returns the signed result of A * B in register D.
+;
+	tsta
+	bmi	A_neg
+	tstb
+	bmi	B_neg
+	mul
+	rts
+B_neg:
+	negb
+	bra	A_or_B_neg
+A_neg:
+	nega
+	tstb
+	bmi	AB_neg
+A_or_B_neg:
+	mul
+	coma
+	comb
+	addd	#1
+	rts
+AB_neg:
+	negb
+	mul
+	rts
+#endif
+	
+#ifdef L_mulhi3
+	declare_near ___mulhi3
+
+;
+;
+;  unsigned short ___mulhi3(unsigned short a, unsigned short b)
+;
+;	a = register D
+;	b = register X
+;
+#ifdef mc68hc12
+	pshx			; Preserve X
+	exg	x,y
+	emul
+	exg	x,y
+	pulx
+	rts
+#else
+#ifdef NO_TMP
+	;
+	; 16 bit multiplication without temp memory location.
+	; (smaller but slower)
+	;
+	pshx			; (4)
+	ins			; (3)
+	pshb			; (3)
+	psha			; (3)
+	pshx			; (4)
+	pula			; (4)
+	pulx			; (5)
+	mul			; (10) B.high * A.low
+	xgdx			; (3)
+	mul			; (10) B.low * A.high
+	abx			; (3)
+	pula			; (4)
+	pulb			; (4)
+	mul			; (10) B.low * A.low
+	pshx			; (4) 
+	tsx			; (3)
+	adda	1,x		; (4)
+	pulx			; (5)
+	rts			; (5) 20 bytes
+				; ---
+				; 91 cycles
+#else
+	stx	*_.tmp		; (4)
+	pshb			; (3)
+	ldab	*_.tmp+1	; (3)
+	mul			; (10) A.high * B.low
+	ldaa	*_.tmp		; (3)
+	stab	*_.tmp		; (3)
+	pulb			; (4)
+	pshb			; (4)
+	mul			; (10) A.low * B.high
+	addb	*_.tmp		; (4)
+	stab	*_.tmp		; (3)
+	ldaa	*_.tmp+1	; (3)
+	pulb			; (4)
+	mul			; (10) A.low * B.low
+	adda	*_.tmp		; (4)
+	rts			; (5) 24/32 bytes
+				; 77/85 cycles
+#endif
+#endif
+#endif
+
+#ifdef L_mulhi32
+
+;
+;
+;  unsigned long __mulhi32(unsigned short a, unsigned short b)
+;
+;	a = register D
+;	b = value on stack
+;
+;	+---------------+
+;       |  B low	| <- 7,x
+;	+---------------+
+;       |  B high	| <- 6,x
+;	+---------------+
+;       |  PC low	|  
+;	+---------------+
+;       |  PC high	|  
+;	+---------------+
+;	|  Tmp low	|
+;	+---------------+
+;	|  Tmp high     |
+;	+---------------+
+;	|  A low	|
+;	+---------------+
+;	|  A high	|
+;	+---------------+  <- 0,x
+;
+;
+;      <B-low>    5,x
+;      <B-high>   4,x
+;      <ret>      2,x
+;      <A-low>    1,x
+;      <A-high>   0,x
+;
+	declare_near	__mulhi32
+
+#ifdef mc68hc12
+	ldy	2,sp
+	emul
+	exg	x,y
+	rts
+#else
+	pshx			; Room for temp value
+	pshb
+	psha
+	tsx
+	ldab	6,x
+	mul
+	xgdy			; A.high * B.high
+	ldab	7,x
+	pula
+	mul			; A.high * B.low
+	std	2,x
+	ldaa	1,x
+	ldab	6,x
+	mul			; A.low * B.high
+	addd	2,x
+	stab	2,x
+	tab
+	aby
+	bcc	N
+	ldab	#0xff
+	aby
+	iny
+N:
+	ldab	7,x
+	pula
+	mul			; A.low * B.low
+	adda	2,x
+	pulx			; Drop temp location
+	pshy			; Put high part in X
+	pulx
+	bcc	Ret
+	inx
+Ret:
+	rts
+#endif	
+#endif
+
+#ifdef L_mulsi3
+
+;
+;      <B-low>    8,y
+;      <B-high>   6,y
+;      <ret>      4,y
+;	<tmp>	  2,y
+;      <A-low>    0,y
+;
+; D,X   -> A
+; Stack -> B
+;
+; The result is:
+;
+;	(((A.low * B.high) + (A.high * B.low)) << 16) + (A.low * B.low)
+;
+;
+;
+
+	declare	__mulsi3
+
+#ifdef mc68hc12
+
+
+	
+	pshd				; Save A.low
+	ldy	ARG(4),sp
+	emul				; A.low * B.high
+	ldy	ARG(6),sp
+	exg	x,d
+	emul				; A.high * B.low
+	leax	d,x
+	ldy	ARG(6),sp
+	puld
+	emul				; A.low * B.low
+	exg	d,y
+	leax	d,x
+	exg	d,y
+	ret
+#else
+B_low	=	ARG(8)
+B_high	=	ARG(6)
+A_low	=	0
+A_high	=	2
+	pshx
+	pshb
+	psha
+	tsy
+;
+; If B.low is 0, optimize into: (A.low * B.high) << 16
+;
+	ldd	B_low,y
+	beq	B_low_zero
+;
+; If A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)
+;
+	cpx	#0
+	beq	A_high_zero
+	bsr	___mulhi3		; A.high * B.low
+;
+; If A.low is 0, optimize into: (A.high * B.low) << 16
+;
+	ldx	A_low,y
+	beq	A_low_zero		; X = 0, D = A.high * B.low
+	std	2,y
+;
+; If B.high is 0, we can avoid the (A.low * B.high) << 16 term.
+;
+	ldd	B_high,y
+	beq	B_high_zero
+	bsr	___mulhi3		; A.low * B.high
+	addd	2,y
+	std	2,y
+;
+; Here, we know that A.low and B.low are not 0.
+;
+B_high_zero:
+	ldd	B_low,y			; A.low is on the stack
+	bsr	__mulhi32		; A.low * B.low
+	xgdx
+	tsy				; Y was clobbered, get it back
+	addd	2,y
+A_low_zero:				; See A_low_zero_non_optimized below
+	xgdx
+Return:
+	ins
+	ins
+	ins
+	ins
+	ret
+;
+; 
+; A_low_zero_non_optimized:
+;
+; At this step, X = 0 and D = (A.high * B.low)
+; Optimize into: (A.high * B.low) << 16
+;
+;	xgdx
+;	clra			; Since X was 0, clearing D is superfuous.
+;	clrb
+;	bra	Return
+; ----------------
+; B.low == 0, the result is:	(A.low * B.high) << 16
+;
+; At this step:
+;   D = B.low				= 0 
+;   X = A.high				?
+;       A.low is at A_low,y		?
+;       B.low is at B_low,y		?
+;
+B_low_zero:
+	ldd	A_low,y
+	beq	Zero1
+	ldx	B_high,y
+	beq	Zero2
+	bsr	___mulhi3
+Zero1:
+	xgdx
+Zero2:
+	clra
+	clrb
+	bra	Return
+; ----------------
+; A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)
+;
+; At this step:
+;   D = B.low				!= 0 
+;   X = A.high				= 0
+;       A.low is at A_low,y		?
+;       B.low is at B_low,y		?
+;
+A_high_zero:
+	ldd	A_low,y		; A.low
+	beq	Zero1
+	ldx	B_high,y	; B.high
+	beq	A_low_B_low
+	bsr	___mulhi3
+	std	2,y
+	bra	B_high_zero	; Do the (A.low * B.low) and the add.
+
+; ----------------
+; A.high and B.high are 0 optimize into: (A.low * B.low)
+;
+; At this step:
+;   D = B.high				= 0 
+;   X = A.low				!= 0
+;       A.low is at A_low,y		!= 0
+;       B.high is at B_high,y		= 0
+;
+A_low_B_low:
+	ldd	B_low,y			; A.low is on the stack
+	bsr	__mulhi32
+	bra	Return
+#endif
+#endif
+
+#ifdef L_map_data
+
+	.sect	.install2,"ax",@progbits
+	.globl	__map_data_section
+	.globl __data_image
+#ifdef mc68hc12
+	.globl __data_section_size
+#endif
+__map_data_section:
+#ifdef mc68hc12
+	ldx	#__data_image
+	ldy	#__data_section_start
+	ldd	#__data_section_size
+	beq	Done
+Loop:
+	movb	1,x+,1,y+
+	dbne	d,Loop
+#else
+	ldx	#__data_image
+	ldy	#__data_section_start
+	bra	Start_map
+Loop:
+	ldaa	0,x
+	staa	0,y
+	inx
+	iny
+Start_map:
+	cpx	#__data_image_end
+	blo	Loop
+#endif
+Done:
+
+#endif
+
+#ifdef L_init_bss
+
+	.sect	.install2,"ax",@progbits
+	.globl	__init_bss_section
+
+__init_bss_section:
+	ldd	#__bss_size
+	beq	Done
+	ldx	#__bss_start
+Loop:
+#ifdef mc68hc12
+	clr	1,x+
+	dbne	d,Loop
+#else
+	clr	0,x
+	inx
+	subd	#1
+	bne	Loop
+#endif
+Done:
+
+#endif
+
+#ifdef L_ctor
+
+; End of constructor table
+	.sect	.install3,"ax",@progbits
+	.globl	__do_global_ctors
+
+__do_global_ctors:
+	; Start from the end - sizeof(void*)
+	ldx	#__CTOR_END__-2
+ctors_loop:
+	cpx	#__CTOR_LIST__
+	blo	ctors_done
+	pshx
+	ldx	0,x
+	jsr	0,x
+	pulx
+	dex
+	dex
+	bra	ctors_loop
+ctors_done:
+
+#endif
+
+#ifdef L_dtor
+
+	.sect	.fini3,"ax",@progbits
+	.globl	__do_global_dtors
+
+;;
+;; This piece of code is inserted in the _exit() code by the linker.
+;;
+__do_global_dtors:
+	pshb	; Save exit code
+	psha
+	ldx	#__DTOR_LIST__
+dtors_loop:
+	cpx	#__DTOR_END__
+	bhs	dtors_done
+	pshx
+	ldx	0,x
+	jsr	0,x
+	pulx
+	inx
+	inx
+	bra	dtors_loop
+dtors_done:
+	pula	; Restore exit code
+	pulb
+
+#endif
+
+#ifdef L_far_tramp
+#ifdef mc68hc12
+	.sect	.tramp,"ax",@progbits
+	.globl	__far_trampoline
+
+;; This is a trampoline used by the linker to invoke a function
+;; using rtc to return and being called with jsr/bsr.
+;; The trampoline generated is:
+;;
+;;	foo_tramp:
+;;		ldy	#foo
+;;		call	__far_trampoline,page(foo)
+;;
+;; The linker transforms:
+;;
+;;		jsr	foo
+;;
+;; into
+;;		jsr	foo_tramp
+;;
+;; The linker generated trampoline and _far_trampoline must be in 
+;; non-banked memory.
+;;
+__far_trampoline:
+	movb	0,sp, 2,sp	; Copy page register below the caller's return
+	leas	2,sp		; address.
+	jmp	0,y		; We have a 'call/rtc' stack layout now
+				; and can jump to the far handler
+				; (whose memory bank is mapped due to the
+				; call to the trampoline).
+#endif
+
+#ifdef mc68hc11
+	.sect	.tramp,"ax",@progbits
+	.globl __far_trampoline
+
+;; Trampoline generated by gcc for 68HC11:
+;;
+;;	pshb
+;;	ldab	#%page(func)
+;;	ldy	#%addr(func)
+;;	jmp	__far_trampoline
+;;
+__far_trampoline:
+	psha				; (2) Save function parameter (high)
+	;; <Read current page in A>
+	psha				; (2)
+	;; <Set currenge page from B>
+	pshx				; (4)
+	tsx				; (3)
+	ldab	4,x			; (4) Restore function parameter (low)
+	ldaa	2,x			; (4) Get saved page number
+	staa	4,x			; (4) Save it below return PC
+	pulx				; (5)
+	pula				; (3)
+	pula				; (3) Restore function parameter (high)
+	jmp	0,y			; (4)
+#endif
+#endif
+
+#ifdef L_call_far
+#ifdef mc68hc11
+	.sect	.tramp,"ax",@progbits
+	.globl __call_a16
+	.globl __call_a32
+;;
+;; The call methods are used for 68HC11 to support memory bank switching.
+;; Every far call is redirected to these call methods.  Its purpose is to:
+;;
+;;  1/ Save the current page on the stack (1 byte to follow 68HC12 call frame)
+;;  2/ Install the new page
+;;  3/ Jump to the real function
+;;
+;; The page switching (get/save) is board dependent.  The default provided
+;; here does nothing (just create the appropriate call frame).
+;;
+;; Call sequence (10 bytes, 13 cycles):
+;;
+;;	ldx #page			; (3)
+;;	ldy #func			; (4)
+;;	jsr __call_a16			; (6)
+;;
+;; Call trampoline (11 bytes, 19 cycles):
+;;
+__call_a16:
+	;; xgdx				; (3)
+	;; <Read current page in A>	; (3) ldaa _current_page
+	psha				; (2)
+	;; <Set current page from B>	; (4) staa _current_page
+	;; xgdx				; (3)
+	jmp 0,y				; (4)
+
+;;
+;; Call sequence (10 bytes, 14 cycles):
+;;
+;;	pshb				; (2)
+;;	ldab #page			; (2)
+;;	ldy  #func			; (4)
+;;	jsr __call_a32			; (6)
+;;
+;; Call trampoline (87 bytes, 57 cycles):
+;;
+__call_a32:
+	pshx				; (4)
+	psha				; (2)
+	;; <Read current page in A>	; (3) ldaa _current_page
+	psha				; (2)
+	;; <Set current page from B>	; (4) staa _current_page
+	tsx				; (3)
+	ldab	6,x			; (4) Restore function parameter
+	ldaa	5,x			; (4) Move PC return at good place
+	staa	6,x			; (4)
+	ldaa	4,x			; (4)
+	staa	5,x			; (4)
+	pula				; (3)
+	staa	4,x			; (4)
+	pula				; (3)
+	pulx				; (5)
+	jmp	0,y			; (4)
+#endif
+#endif
+
+#ifdef L_return_far
+#ifdef mc68hc11
+	.sect	.tramp,"ax",@progbits
+       .globl __return_void
+       .globl __return_16
+       .globl __return_32
+
+__return_void:
+	;; pulb
+	;; <Set current page from B> (Board specific)
+	;; rts
+__return_16:
+	;; xgdx
+	;; pulb
+	;; <Set current page from B> (Board specific)
+	;; xgdx
+	;; rts
+__return_32:
+	;; xgdy
+	;; pulb
+	;; <Set current page from B> (Board specific)
+	;; xgdy
+	;; rts
+	ins
+	rts
+#endif
+#endif
+.Lend:
+;-----------------------------------------
+; end required gcclib code
+;-----------------------------------------
diff -rupN gcc-3.3.6/gcc/config/m68hc11/larith.asm gcc-3.3.6-s12x/gcc/config/m68hc11/larith.asm
--- gcc-3.3.6/gcc/config/m68hc11/larith.asm	2016-12-11 19:32:34.670647776 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/larith.asm	2016-12-11 19:32:40.894702914 +0100
@@ -35,6 +35,10 @@ Boston, MA 02111-1307, USA.  */
 
 	.file "larith.asm"
 
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+  #error No target defined for larith.asm
+#endif
+
 #ifdef __HAVE_SHORT_INT__
 	.mode mshort
 #else
@@ -402,18 +406,30 @@ End:
 	std	6,y			; Save, borrow preserved
 
 	ldd	ARG(6),x
+#if defined(m9s12x)
+    sbed    ARG(14),x
+#else
 	sbcb	ARG(15),x
 	sbca	ARG(14),x
+#endif
 	std	4,y
 
 	ldd	ARG(4),x
+#if defined(m9s12x)
+	sbed	ARG(12),x
+#else
 	sbcb	ARG(13),x
 	sbca	ARG(12),x
+#endif
 	std	2,y
 	
 	ldd	ARG(2),x		; Subtract MSB
+#if defined(m9s12x)
+	sbed	ARG(10),x
+#else
 	sbcb	ARG(11),x
 	sbca	ARG(10),x
+#endif
 	std	0,y
 
 	xgdy			;
@@ -469,10 +485,14 @@ done:
 
 	comb
 	coma
+#if defined(m9s12x)
+    comx
+#else
 	xgdx
 	comb
 	coma
 	xgdx
+#endif
 	rts
 #endif
 	
@@ -486,10 +506,14 @@ done:
 	beq	Return
 Loop:
 	lsld
+#if defined(m9s12x)
+    rolx
+#else
 	xgdx
 	rolb
 	rola
 	xgdx
+#endif
 	dey
 	bne	Loop
 Return:
@@ -505,10 +529,14 @@ Return:
 	xgdy
 	beq	Return
 Loop:
+#if defined(m9s12x)
+    asrx
+#else
 	xgdx
 	asra
 	rorb
 	xgdx
+#endif
 	rora
 	rorb
 	dey
@@ -526,9 +554,13 @@ Return:
 	xgdy
 	beq	Return
 Loop:
+#if defined(m9s12x)
+    lsrx
+#else
 	xgdx
 	lsrd
 	xgdx
+#endif
 	rora
 	rorb
 	dey
@@ -579,10 +611,14 @@ Return_zero:
 	declare_near ___rotrhi3
 
 ___rotrhi3:
+#if defined(m9s12x)
+    andx    #0x000f
+#else
 	xgdx
 	clra
 	andb	#0x0f
 	xgdx
+#endif
 	beq	Return
 Loop:
 	tap
@@ -598,10 +634,14 @@ Return:
 	declare_near ___rotlhi3
 
 ___rotlhi3:
+#if defined(m9s12x)
+    andx    #0x000f
+#else
 	xgdx
 	clra
 	andb	#0x0f
 	xgdx
+#endif
 	beq	Return
 Loop:
 	asrb
@@ -951,6 +991,9 @@ Ret:
 	declare	__mulsi3
 
 #ifdef mc68hc12
+
+
+	
 	pshd				; Save A.low
 	ldy	ARG(4),sp
 	emul				; A.low * B.high
diff -rupN gcc-3.3.6/gcc/config/m68hc11/ldivmod.asm gcc-3.3.6-s12x/gcc/config/m68hc11/ldivmod.asm
--- gcc-3.3.6/gcc/config/m68hc11/ldivmod.asm	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/ldivmod.asm	2016-12-11 19:32:40.894702914 +0100
@@ -0,0 +1,584 @@
+;;;-----------------------------------------
+
+;;;  Hand coded div and mod functions.
+;;;  AES 2009
+;;;	 for S12X platform
+;;;-----------------------------------------
+
+; Re-coded for m68hc12 as well - James Murray October 2010
+	
+	.file "ldivmod.asm"
+
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+  #error No target defined for ldivmod.asm
+#endif
+
+#if defined(mc68hc12) || defined(m9s12x)
+
+#ifdef __HAVE_SHORT_INT__
+	.mode mshort
+#else
+	.mode mlong
+#endif
+
+	.macro declare_near name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#if defined(__USE_RTC__)
+# define ARG(N) N+1
+
+	.macro ret
+#if defined(mc68hc12)
+	rtc
+#else
+	jmp __return_32
+#endif
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+	.far   \name
+\name:
+	.endm
+
+	.macro farsym name
+	.far NAME
+	.endm
+
+#else
+# define ARG(N) N
+
+	.macro ret
+	rts
+	.endm
+
+	.macro farsym name
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#endif
+
+	.sect .text
+	
+
+#define REG(NAME)			\
+NAME:	.dc.w	1;			\
+	.type NAME,@object ;		\
+	.size NAME,2
+
+#ifdef L_regs_min
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+
+	.sect .softregs
+	.globl _.tmp
+
+REG(_.tmp)
+#endif
+
+
+
+/* ok, guessing that we get called with a in D and X and B on stack */
+
+;;; 
+;;; long __divsi3 ( long num, long den )
+;;;
+
+;;; d == num_low
+;;; x == num_high
+
+;;; sp, ARG(4)  == den_high
+;;; sp, ARG(6)  == den_low
+;;; return result in XD
+
+;;; calling here we have also pushed 4 extra bytes on stack
+;;;  and we dont use a frame pointer
+
+
+udivmodsi:
+	pshy				; preserve y
+	pshd				; save numerator in case ediv fails
+	pshx
+#ifndef m9s12x
+	tst 	ARG(10), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+	tst 	ARG(11), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+#else
+	tstw 	ARG(10), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+#endif
+	tfr 	x,y			; load num_high into y
+	ldx	ARG(12), sp		; load denominator into x
+	ediv
+	bvs	go_soft_udivmodsi 	; overflow ??
+
+	;; overwrite denominator on stack with modulus
+	;; this is ok since c copies args onto stack  (???CHECKME)
+
+	std	ARG(12), sp
+#ifndef m9s12x
+	clr 	ARG(10), sp
+	clr 	ARG(11), sp
+#else
+	clrw 	ARG(10), sp
+#endif
+
+	;; return division  results in X:D
+#ifndef m9s12x
+    ldx #0
+#else
+	clrx
+#endif
+	tfr	y,d
+	
+	leas 	4, sp		  	; deallocate stack for numerator save
+	puly				; retrieve y
+	rts
+
+go_soft_udivmodsi:
+#ifndef m9s12x
+    ldy #0
+#else
+	clry
+#endif
+	bra 	soft_udivmodsi
+	
+
+divmodsi:	
+
+	pshy			; preserve y
+	pshd			; save numerator in case edivs fails
+	pshx
+	ldy	ARG(10),sp	; denominator fits in signed int16  ??
+	beq	test_pos
+#ifndef m9s12x
+    xgdy
+    coma
+    comb
+    xgdy
+#else
+	comy
+#endif
+	beq	test_neg
+	bra	soft_divmodsi
+test_pos:	
+	ldy	ARG(12),sp
+	bpl	hard_divmodsi 	
+	bra	soft_divmodsi
+
+test_neg:
+	ldy	ARG(12),sp
+	bpl	soft_divmodsi
+	
+hard_divmodsi:
+	
+	exg 	x,y
+	edivs			; attempt a divide by hardware
+	bvs  	soft_divmodsi     	; an overflow happened ... do soft divide
+
+#ifndef m9s12x
+	clr 	ARG(10),sp
+	clr 	ARG(11),sp
+#else
+	clrw 	ARG(10),sp
+#endif
+	std	ARG(12), sp
+	bpl	skip_hdsx_mod   ; sign extend modulus
+	movw	#0xFFFF, ARG(10), sp 	
+skip_hdsx_mod:	
+
+
+	;; returned division  results in X:D
+#ifndef m9s12x
+    ldx #0
+    xgdy
+    tsta
+    xgdy
+#else
+	clrx
+	tsty
+#endif
+	bpl	skip_hdsx_div   ; sign extend result
+	ldx    #0xFFFF
+	
+skip_hdsx_div:	
+	tfr	y,d	
+	leas    4,sp		; deallocate stack
+	puly			; retrieve y
+	rts
+
+soft_divmodsi:
+	;; numerator in sp and sp+1 ; den in ARG(10) and ARG(12)
+#ifndef m9s12x
+    ldy #0
+#else
+	clry	              ; use y to evaluate sign of result
+#endif
+	tst	0, sp       ; was tstw
+	bpl	sd_skip_neg_num
+
+#ifndef m9s12x
+    xgdy
+    orab    #3
+    xgdy
+    com     3, sp
+    com     2, sp
+    com     1, sp
+    com     0, sp
+	inc	    3, sp
+	bne	sd_skip_neg_num
+	inc	    2, sp
+	bne	sd_skip_neg_num
+	inc	    1, sp
+	bne	sd_skip_neg_num
+	inc 	0, sp
+#else
+	ory    #3
+	comw	2, sp
+	comw  	0, sp
+	incw	2, sp
+	bne	sd_skip_neg_num
+	incw	0, sp
+#endif
+	
+sd_skip_neg_num:
+
+	tst 	ARG(10), sp
+	bpl	sd_skip_neg_den ; was tstw
+
+#ifndef m9s12x
+    xgdy
+    eorb    #1
+    xgdy
+	com 	ARG(13), sp
+	com 	ARG(12), sp
+	com 	ARG(11), sp
+	com 	ARG(10), sp
+	inc	    ARG(13), sp
+	bne	sd_skip_neg_den
+	inc	    ARG(12), sp
+	bne	sd_skip_neg_den
+	inc	    ARG(11), sp
+	bne	sd_skip_neg_den
+	inc	    ARG(10), sp
+#else
+	eory	#1
+	comw 	ARG(12), sp
+	comw 	ARG(10),  sp
+	incw	ARG(12), sp
+	bne	sd_skip_neg_den
+	incw	ARG(10),  sp
+#endif	
+
+sd_skip_neg_den:
+soft_udivmodsi:	    		; if called from udivmodsi
+				; make sure y=0  
+	leas -8,sp		; allocate for 'bit' and 'res' 
+	
+	;; stack should look like this on entry if  ARG(N)=N:
+
+	;; 
+	;; 
+	;; 
+	;; denominator (SI)                             ---  sp+18
+	;; 
+	;; return address for calling function  (HI)   sp+16
+	;; 
+	;; return address for frontend  function (HI) sp+14
+	;;
+	;; preserve y	   ----  sp+12
+	;; 
+	;; 
+	;; 
+	;; numerator (SI)  ----  sp+8
+	;;
+	;;
+	;;
+	;; bit (SI)        ----  sp+4
+	;;
+	;; 
+	;; 
+	;; res (SI)        ----  sp
+	
+#ifndef m9s12x
+	clr 	0, sp		; res = 0
+	clr	    1, sp
+	clr	    2, sp
+	clr	    3, sp
+	tst	ARG(18),sp
+	bne     checked_den
+	tst	ARG(19),sp
+	bne     checked_den
+	tst	ARG(20),sp
+	bne     checked_den
+	tst	ARG(21),sp
+	beq	while_end
+#else
+	clrw 	0, sp		; res = 0
+	clrw	2, sp
+	tstw	ARG(18),sp
+	bne     checked_den
+	tstw	ARG(20),sp
+	beq	while_end
+#endif
+	
+checked_den:	
+
+	movw	#1, 6, sp
+#ifndef m9s12x
+	clr	    4,sp            ; bit = 1
+	clr	    5,sp            ; bit = 1
+#else
+	clrw	4,sp            ; bit = 1
+#endif
+
+while_den:			; while ((den < num) && !(den.bit31))
+	tst 	ARG(18), sp ; was tstw
+	bmi 	while_bit
+	ldd	10,sp
+	ldx	8,sp
+
+	subd 	ARG(20), sp
+#ifndef m9s12x
+    xgdx
+    sbcb    ARG(19), sp
+    sbca    ARG(18), sp
+    xgdx
+#else
+	sbex	ARG(18), sp
+#endif
+	bcs	while_bit
+
+#ifndef m9s12x
+	asl	    ARG(21), sp     ;  den <<= 1
+	rol	    ARG(20), sp
+	rol	    ARG(19), sp
+	rol	    ARG(18), sp
+
+	asl	    7,sp		; bit <<= 1
+	rol	    6,sp			
+	rol	    5,sp			
+	rol	    4,sp			
+#else
+	aslw	ARG(20), sp     ;  den <<= 1
+	rolw	ARG(18), sp
+
+	aslw	6,sp		; bit <<= 1
+	rolw	4,sp			
+#endif
+
+	bra	while_den
+
+
+while_bit:			; while  (bit!=0)
+#ifndef m9s12x
+	tst	    4, sp
+	bne	while_bit_ok
+	tst	    5, sp
+	bne	while_bit_ok
+	tst	    6, sp
+	bne	while_bit_ok
+	tst	    7,sp
+	beq	while_end
+#else
+	tstw	4, sp
+	bne	while_bit_ok
+	tstw	6,sp
+	beq	while_end
+#endif
+
+while_bit_ok:
+	
+	ldd 	10, sp		; if (num >= den) 
+	ldx	8, sp
+	subd	ARG(20),sp
+#ifndef m9s12x
+    xgdx
+    sbcb    ARG(19),sp
+    sbca    ARG(18),sp
+    xgdx
+#else
+	sbex	ARG(18),sp
+#endif
+	bcs	skip_restore   	; here was bmi
+
+	std	10,sp		; num-=den
+	stx	8,sp
+
+#ifndef m9s12x
+	ldd	    0,sp		; res|= bit
+	oraa	4,sp
+	orab	5,sp
+	std	    0,sp
+	ldd	    2,sp
+	oraa	6,sp
+	orab	7,sp
+	std	    2,sp
+#else
+	ldx	    0,sp		; res|= bit
+	orx	    4,sp
+	stx	    0,sp
+	ldx	    2,sp
+	orx	    6,sp
+	stx	    2,sp
+#endif
+
+skip_restore:
+	
+#ifndef m9s12x
+	lsr	    4,sp 		; bit >>=1
+	ror	    5,sp		
+	ror	    6,sp		
+	ror	    7,sp		
+	
+	lsr 	ARG(18),sp		; den >>=1
+	ror 	ARG(19),sp
+	ror 	ARG(20),sp
+	ror 	ARG(21),sp
+#else
+	lsrw	4,sp 		; bit >>=1
+	rorw	6,sp		
+	
+	lsrw	ARG(18),sp		; den >>=1
+	rorw	ARG(20),sp
+#endif
+	
+	bra while_bit
+	
+while_end:
+	;; numerator contains mod
+	;; overwrite denominator with it on stack for return
+//	movw	8,sp,ARG(18), sp 
+//	movw	10,sp, ARG(20), sp
+	leax	ARG(18), sp
+	movw	8,sp, 0,x
+	movw	10,sp, 2,x
+	
+	ldx	0,sp
+	ldd 	2,sp
+
+	leas	12,sp 		; deallocate locals
+#ifndef m9s12x
+    xgdy			; do we need to negate result ?
+    tsta
+    bne no_end
+	tstb
+    bne no_end
+    xgdy
+	bra	end_division
+no_end:
+    xgdy
+#else
+	tsty			; do we need to negate result ?
+	beq	end_division
+#endif
+					
+	;; 	if y&1 then negate result
+	;; 	if y&2 then negate modulus
+
+	pshy
+#ifndef m9s12x
+    xgdy
+    andb    #1
+    xgdy
+#else
+	andy	#1
+#endif
+	puly
+	beq	skip_end_res_neg
+	
+	coma
+	comb
+#ifndef m9s12x
+    xgdx
+    coma
+    comb
+    xgdx
+#else
+	comx
+#endif
+	incb
+	bne	end_division
+	inca	
+	bne	end_division
+	inx	
+
+skip_end_res_neg:
+#ifndef m9s12x
+    xgdy
+    andb    #2
+    xgdy
+#else
+	andy	#2
+#endif
+	beq	end_division
+
+#ifndef m9s12x
+	com 	ARG(6), sp
+	com 	ARG(7), sp
+	com 	ARG(8), sp
+	com 	ARG(9), sp
+	inc	    ARG(9), sp
+	bne	end_division
+	inc	    ARG(8), sp
+	bne	end_division
+	inc	    ARG(7), sp
+	bne	end_division
+	inc	    ARG(6),  sp
+#else
+	comw 	ARG(6), sp
+	comw 	ARG(8), sp
+	incw	ARG(8), sp
+	bne	end_division
+	incw	ARG(6),  sp
+#endif
+	
+end_division:
+	puly
+	rts
+
+
+	
+;;;  si3 frontends for divmodsi3
+	
+	declare __divsi3
+	bsr	divmodsi
+	ret
+	
+	declare __modsi3
+
+	bsr 	divmodsi
+	ldx	ARG(2), sp	; stack has two less on it now
+	ldd	ARG(4), sp	
+	ret
+
+	declare __umodsi3
+	bsr 	udivmodsi
+	ldx	ARG(2), sp
+	ldd	ARG(4), sp	
+	ret
+	
+	
+	declare __udivsi3
+	bsr 	udivmodsi
+	ret
+	
+#endif
+
+.Lend:
+;-----------------------------------------
+; end required gcclib code
+;-----------------------------------------
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m68hc11.c gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11.c
--- gcc-3.3.6/gcc/config/m68hc11/m68hc11.c	2016-12-11 19:32:34.674647811 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11.c	2016-12-11 19:32:40.898702949 +0100
@@ -1,21 +1,22 @@
 /* Subroutines for code generation on Motorola 68HC11 and 68HC12.
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
    Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
-This file is part of GNU CC.
+This file is part of GCC.
 
-GNU CC is free software; you can redistribute it and/or modify
+GCC is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
 
-GNU CC is distributed in the hope that it will be useful,
+GCC is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with GNU CC; see the file COPYING.  If not, write to
+along with GCC; see the file COPYING.  If not, write to
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
 
@@ -70,6 +71,7 @@ static int autoinc_mode PARAMS ((rtx));
 static int m68hc11_make_autoinc_notes PARAMS ((rtx*, void*));
 static int m68hc11_auto_inc_p PARAMS ((rtx));
 static tree m68hc11_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));
+static tree m68hc11_handle_page0_attribute PARAMS ((tree *, tree, tree, int, bool *));
 const struct attribute_spec m68hc11_attribute_table[];
 
 void create_regs_rtx PARAMS ((void));
@@ -79,6 +81,7 @@ static void m68hc11_output_function_epil
 static void m68hc11_asm_out_constructor PARAMS ((rtx, int));
 static void m68hc11_asm_out_destructor PARAMS ((rtx, int));
 static void m68hc11_encode_section_info PARAMS((tree, int));
+static const char *m68hc11_strip_name_encoding (const char* str);
 
 /* Must be set to 1 to produce debug messages.  */
 int debug_m6811 = 0;
@@ -129,6 +132,16 @@ unsigned char m68hc11_reg_valid_for_inde
    This is 1 for 68HC11 and 0 for 68HC12.  */
 int m68hc11_sp_correction;
 
+#define ADDR_STRICT       0x01  /* Accept only registers in class A_REGS  */
+#define ADDR_INCDEC       0x02  /* Post/Pre inc/dec */
+#define ADDR_INDEXED      0x04  /* D-reg index */
+#define ADDR_OFFSET       0x08
+#define ADDR_INDIRECT     0x10  /* Accept (mem (mem ...)) for [n,X] */
+#define ADDR_CONST        0x20  /* Accept const and symbol_ref  */
+
+int m68hc11_addr_mode;
+int m68hc11_mov_addr_mode;
+
 /* Comparison operands saved by the "tstxx" and "cmpxx" expand patterns.  */
 rtx m68hc11_compare_op0;
 rtx m68hc11_compare_op1;
@@ -227,6 +240,9 @@ static int nb_soft_regs;
 #undef TARGET_ENCODE_SECTION_INFO
 #define TARGET_ENCODE_SECTION_INFO  m68hc11_encode_section_info
 
+#undef TARGET_STRIP_NAME_ENCODING
+#define TARGET_STRIP_NAME_ENCODING m68hc11_strip_name_encoding
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 int
@@ -264,6 +280,8 @@ m68hc11_override_options ()
       m68hc11_reg_valid_for_base[HARD_Z_REGNUM] = 1;
       m68hc11_sp_correction = 1;
       m68hc11_tmp_regs_class = D_REGS;
+      m68hc11_addr_mode = ADDR_OFFSET;
+      m68hc11_mov_addr_mode = 0;
       if (m68hc11_soft_reg_count == 0 && !TARGET_M6812)
 	m68hc11_soft_reg_count = "4";
     }
@@ -283,6 +301,10 @@ m68hc11_override_options ()
       m68hc11_reg_valid_for_index[HARD_D_REGNUM] = 1;
       m68hc11_sp_correction = 0;
       m68hc11_tmp_regs_class = TMP_REGS;
+      m68hc11_addr_mode = ADDR_INDIRECT | ADDR_OFFSET | ADDR_CONST
+        | (TARGET_AUTO_INC_DEC ? ADDR_INCDEC : 0);
+      m68hc11_mov_addr_mode = ADDR_OFFSET | ADDR_CONST
+        | (TARGET_AUTO_INC_DEC ? ADDR_INCDEC : 0);
       target_flags &= ~MASK_M6811;
       target_flags |= MASK_NO_DIRECT_MODE;
       if (m68hc11_soft_reg_count == 0)
@@ -316,7 +338,7 @@ m68hc11_conditional_register_usage ()
   /* For 68HC12, the Z register emulation is not necessary when the
      frame pointer is not used.  The frame pointer is eliminated and
      replaced by the stack register (which is a BASE_REG_CLASS).  */
-  if (TARGET_M6812 && flag_omit_frame_pointer && optimize)
+  if (TARGET_M6812 && flag_omit_frame_pointer && optimize && 0)
     {
       fixed_regs[HARD_Z_REGNUM] = 1;
     }
@@ -385,8 +407,9 @@ hard_regno_mode_ok (regno, mode)
 }
 
 int
-m68hc11_hard_regno_rename_ok (reg1, reg2)
+m68hc11_hard_regno_rename_ok (reg1, reg2, mode)
      int reg1, reg2;
+     int mode;
 {
   /* Don't accept renaming to Z register.  We will replace it to
      X,Y or D during machine reorg pass.  */
@@ -398,6 +421,11 @@ m68hc11_hard_regno_rename_ok (reg1, reg2
       && (D_REGNO_P (reg1) || X_REGNO_P (reg1)))
     return 0;
 
+  /* Don't rename D as if it holds a 8-bit value, the code will be
+     bigger.  */
+  if (mode == QImode && D_REGNO_P (reg1))
+    return 0;
+
   return 1;
 }
 
@@ -522,21 +550,25 @@ preferred_reload_class (operand, class)
    For 68hc11:  n,r    with n in [0..255] and r in A_REGS class
    For 68hc12:  n,r    no constraint on the constant, r in A_REGS class.  */
 static int
-register_indirect_p (operand, mode, strict)
-     rtx operand;
-     enum machine_mode mode;
-     int strict;
+register_indirect_p (rtx operand, enum machine_mode mode, int addr_mode)
 {
   rtx base, offset;
 
   switch (GET_CODE (operand))
     {
+    case MEM:
+      if ((addr_mode & ADDR_INDIRECT) && GET_MODE_SIZE (mode) <= 2)
+        return register_indirect_p (XEXP (operand, 0), mode,
+                                    addr_mode & (ADDR_STRICT | ADDR_OFFSET));
+      return 0;
+
     case POST_INC:
     case PRE_INC:
     case POST_DEC:
     case PRE_DEC:
-      if (TARGET_M6812 && TARGET_AUTO_INC_DEC)
-	return register_indirect_p (XEXP (operand, 0), mode, strict);
+      if (addr_mode & ADDR_INCDEC)
+	return register_indirect_p (XEXP (operand, 0), mode,
+                                    addr_mode & ADDR_STRICT);
       return 0;
 
     case PLUS:
@@ -548,36 +580,57 @@ register_indirect_p (operand, mode, stri
       if (GET_CODE (offset) == MEM)
 	return 0;
 
+      /* Indexed addressing mode with 2 registers.  */
+      if (GET_CODE (base) == REG && GET_CODE (offset) == REG)
+        {
+          if (!(addr_mode & ADDR_INDEXED))
+            return 0;
+
+          addr_mode &= ADDR_STRICT;
+          if (REGNO_OK_FOR_BASE_P2 (REGNO (base), addr_mode)
+              && REGNO_OK_FOR_INDEX_P2 (REGNO (offset), addr_mode))
+            return 1;
+
+          if (REGNO_OK_FOR_BASE_P2 (REGNO (offset), addr_mode)
+              && REGNO_OK_FOR_INDEX_P2 (REGNO (base), addr_mode))
+            return 1;
+
+          return 0;
+        }
+
+      if (!(addr_mode & ADDR_OFFSET))
+        return 0;
+
       if (GET_CODE (base) == REG)
 	{
-	  if (!VALID_CONSTANT_OFFSET_P (offset, mode))
+          if (!VALID_CONSTANT_OFFSET_P (offset, mode))
 	    return 0;
 
-	  if (strict == 0)
+	  if (!(addr_mode & ADDR_STRICT))
 	    return 1;
 
-	  return REGNO_OK_FOR_BASE_P2 (REGNO (base), strict);
+	  return REGNO_OK_FOR_BASE_P2 (REGNO (base), 1);
 	}
+
       if (GET_CODE (offset) == REG)
 	{
 	  if (!VALID_CONSTANT_OFFSET_P (base, mode))
 	    return 0;
 
-	  if (strict == 0)
+	  if (!(addr_mode & ADDR_STRICT))
 	    return 1;
 
-	  return REGNO_OK_FOR_BASE_P2 (REGNO (offset), strict);
+	  return REGNO_OK_FOR_BASE_P2 (REGNO (offset), 1);
 	}
       return 0;
 
     case REG:
-      return REGNO_OK_FOR_BASE_P2 (REGNO (operand), strict);
+      return REGNO_OK_FOR_BASE_P2 (REGNO (operand), addr_mode & ADDR_STRICT);
 
     case CONST_INT:
-      if (TARGET_M6811)
-        return 0;
-
-      return VALID_CONSTANT_OFFSET_P (operand, mode);
+      if (addr_mode & ADDR_CONST)
+        return VALID_CONSTANT_OFFSET_P (operand, mode);
+      return 0;
 
     default:
       return 0;
@@ -592,6 +645,7 @@ m68hc11_small_indexed_indirect_p (operan
      enum machine_mode mode;
 {
   rtx base, offset;
+  int addr_mode;
 
   if (GET_CODE (operand) == REG && reload_in_progress
       && REGNO (operand) >= FIRST_PSEUDO_REGISTER
@@ -611,7 +665,8 @@ m68hc11_small_indexed_indirect_p (operan
   if (PUSH_POP_ADDRESS_P (operand))
     return 1;
 
-  if (!register_indirect_p (operand, mode, reload_completed))
+  addr_mode = m68hc11_mov_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+  if (!register_indirect_p (operand, mode, addr_mode))
     return 0;
 
   if (TARGET_M6812 && GET_CODE (operand) == PLUS
@@ -654,12 +709,21 @@ m68hc11_register_indirect_p (operand, mo
      rtx operand;
      enum machine_mode mode;
 {
+  int addr_mode;
+
+  if (GET_CODE (operand) == REG && reload_in_progress
+      && REGNO (operand) >= FIRST_PSEUDO_REGISTER
+      && reg_equiv_memory_loc[REGNO (operand)])
+    {
+      operand = reg_equiv_memory_loc[REGNO (operand)];
+      operand = eliminate_regs (operand, 0, NULL_RTX);
+    }
   if (GET_CODE (operand) != MEM)
     return 0;
 
   operand = XEXP (operand, 0);
-  return register_indirect_p (operand, mode,
-                              (reload_completed | reload_in_progress));
+  addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+  return register_indirect_p (operand, mode, addr_mode);
 }
 
 static int
@@ -668,6 +732,8 @@ go_if_legitimate_address_internal (opera
      enum machine_mode mode;
      int strict;
 {
+  int addr_mode;
+
   if (CONSTANT_ADDRESS_P (operand) && TARGET_M6812)
     {
       /* Reject the global variables if they are too wide.  This forces
@@ -677,7 +743,8 @@ go_if_legitimate_address_internal (opera
 
       return 1;
     }
-  if (register_indirect_p (operand, mode, strict))
+  addr_mode = m68hc11_addr_mode | (strict ? ADDR_STRICT : 0);
+  if (register_indirect_p (operand, mode, addr_mode))
     {
       return 1;
     }
@@ -930,6 +997,27 @@ cmp_operand (operand, mode)
   return general_operand (operand, mode);
 }
 
+/* Predicate for nonimmediate operands but which rejects the
+   auto-increment/decrement modes.  We must use this predicate
+   for operand 0 (and sometimes operand 1) when an insn can have
+   an operand that would create a RELOAD_OTHER in which a reload
+   part (RELOAD_FOR_OUTPUT_ADDRESS) could be created.  When this
+   happens, the RELOAD_FOR_OUTPUT_ADDRESS is emitted after the RELOAD_OTHER
+   and this will not be valid.  */
+int
+nonimmediate_noinc_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (GET_CODE (operand) == MEM)
+    {
+      rtx addr = XEXP (operand, 0);
+      if (m68hc11_auto_inc_p (addr))
+	return 0;
+    }
+  return nonimmediate_operand (operand, mode);
+}
+
 int
 non_push_operand (operand, mode)
      rtx operand;
@@ -944,6 +1032,43 @@ non_push_operand (operand, mode)
 }
 
 int
+splitable_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (general_operand (operand, mode) == 0)
+    return 0;
+
+  if (push_operand (operand, mode) == 1)
+    return 0;
+
+  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand
+     need to split such addresses to access the low and high part but it
+     is not possible to express a valid address for the low part.  */
+  if (mode != QImode && GET_CODE (operand) == MEM
+      && GET_CODE (XEXP (operand, 0)) == MEM)
+    return 0;
+  return 1;
+}
+
+int
+push_or_splitable_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (general_operand (operand, mode) == 0)
+    return 0;
+
+  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand
+     need to split such addresses to access the low and high part but it
+     is not possible to express a valid address for the low part.  */
+  if (mode != QImode && GET_CODE (operand) == MEM
+      && GET_CODE (XEXP (operand, 0)) == MEM)
+    return 0;
+  return 1;
+}
+
+int
 reg_or_some_mem_operand (operand, mode)
      rtx operand;
      enum machine_mode mode;
@@ -951,6 +1076,7 @@ reg_or_some_mem_operand (operand, mode)
   if (GET_CODE (operand) == MEM)
     {
       rtx op = XEXP (operand, 0);
+      int addr_mode;
 
       if (symbolic_memory_operand (op, mode))
 	return 1;
@@ -958,10 +1084,20 @@ reg_or_some_mem_operand (operand, mode)
       if (IS_STACK_PUSH (operand))
 	return 1;
 
-      if (m68hc11_register_indirect_p (operand, mode))
-	return 1;
+      if (GET_CODE (operand) == REG && reload_in_progress
+          && REGNO (operand) >= FIRST_PSEUDO_REGISTER
+          && reg_equiv_memory_loc[REGNO (operand)])
+         {
+            operand = reg_equiv_memory_loc[REGNO (operand)];
+            operand = eliminate_regs (operand, 0, NULL_RTX);
+         }
+      if (GET_CODE (operand) != MEM)
+         return 0;
 
-      return 0;
+      operand = XEXP (operand, 0);
+      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+      addr_mode &= ~ADDR_INDIRECT;
+      return register_indirect_p (operand, mode, addr_mode);
     }
 
   return register_operand (operand, mode);
@@ -987,18 +1123,23 @@ m68hc11_indirect_p (operand, mode)
      rtx operand;
      enum machine_mode mode;
 {
-  if (GET_CODE (operand) == MEM)
+  if (GET_CODE (operand) == MEM && GET_MODE (operand) == mode)
     {
       rtx op = XEXP (operand, 0);
+      int addr_mode;
+
+      if (m68hc11_page0_symbol_p (op))
+        return 1;
 
       if (symbolic_memory_operand (op, mode))
-	return 0;
+	return TARGET_M6812;
 
       if (reload_in_progress)
         return 1;
 
       operand = XEXP (operand, 0);
-      return register_indirect_p (operand, mode, reload_completed);
+      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+      return register_indirect_p (operand, mode, addr_mode);
     }
   return 0;
 }
@@ -1234,6 +1375,31 @@ m68hc11_initialize_trampoline (tramp, fn
 
 /* Declaration of types.  */
 
+/* Handle an "tiny_data" attribute; arguments as in
+   struct attribute_spec.handler.  */
+static tree
+m68hc11_handle_page0_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  tree decl = *node;
+
+  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
+    {
+      DECL_SECTION_NAME (decl) = build_string (6, ".page0");
+    }
+  else
+    {
+      warning ("`%s' attribute ignored", IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 const struct attribute_spec m68hc11_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
@@ -1241,6 +1407,7 @@ const struct attribute_spec m68hc11_attr
   { "trap",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },
   { "far",       0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },
   { "near",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },
+  { "page0",     0, 0, false, false, false, m68hc11_handle_page0_attribute },
   { NULL,        0, 0, false, false, false, NULL }
 };
 
@@ -1271,6 +1438,52 @@ m68hc11_handle_fntype_attribute (node, n
 
   return NULL_TREE;
 }
+/* Undo the effects of the above.  */
+
+static const char *
+m68hc11_strip_name_encoding (str)
+     const char *str;
+{
+  return str + (*str == '*' || *str == '@' || *str == '&');
+}
+
+static void
+m68hc11_encode_label (tree decl)
+{
+  const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);
+  int len = strlen (str);
+  char *newstr = alloca (len + 2);
+
+  newstr[0] = '@';
+  strcpy (&newstr[1], str);
+
+  XSTR (XEXP (DECL_RTL (decl), 0), 0) = ggc_alloc_string (newstr, len + 1);
+}
+
+/* Return 1 if this is a symbol in page0  */
+int
+m68hc11_page0_symbol_p (rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case SYMBOL_REF:
+      return XSTR (x, 0) != 0 && XSTR (x, 0)[0] == '@';
+
+    case CONST:
+      return m68hc11_page0_symbol_p (XEXP (x, 0));
+
+    case PLUS:
+      if (!m68hc11_page0_symbol_p (XEXP (x, 0)))
+        return 0;
+
+      return GET_CODE (XEXP (x, 1)) == CONST_INT
+        && INTVAL (XEXP (x, 1)) < 256
+        && INTVAL (XEXP (x, 1)) >= 0;
+
+    default:
+      return 0;
+    }
+}
 
 /* We want to recognize trap handlers so that we handle calls to traps
    in a special manner (by issuing the trap).  This information is stored
@@ -1286,6 +1499,13 @@ m68hc11_encode_section_info (decl, first
   int is_far = 0;
   rtx rtl;
   
+  if (TREE_CODE (decl) == VAR_DECL)
+    {
+      if (lookup_attribute ("page0", DECL_ATTRIBUTES (decl)) != 0)
+        m68hc11_encode_label (decl);
+      return;
+    }
+
   if (TREE_CODE (decl) != FUNCTION_DECL)
     return;
 
@@ -1372,15 +1592,19 @@ m68hc11_initial_elimination_offset (from
   /* For a trap handler, we must take into account the registers which
      are pushed on the stack during the trap (except the PC).  */
   func_attr = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
+  current_function_interrupt = lookup_attribute ("interrupt",
+						 func_attr) != NULL_TREE;
+  trap_handler = lookup_attribute ("trap", func_attr) != NULL_TREE;
 
   if (lookup_attribute ("far", func_attr) != 0)
     current_function_far = 1;
   else if (lookup_attribute ("near", func_attr) != 0)
     current_function_far = 0;
   else
-    current_function_far = TARGET_LONG_CALLS != 0;
+    current_function_far = (TARGET_LONG_CALLS != 0
+                            && !current_function_interrupt
+                            && !trap_handler);
 
-  trap_handler = lookup_attribute ("trap", func_attr) != NULL_TREE;
   if (trap_handler && from == ARG_POINTER_REGNUM)
     size = 7;
 
@@ -1679,7 +1903,9 @@ expand_prologue ()
   else if (lookup_attribute ("near", func_attr) != NULL_TREE)
     current_function_far = 0;
   else
-    current_function_far = TARGET_LONG_CALLS != 0;
+    current_function_far = (TARGET_LONG_CALLS != 0
+                            && !current_function_interrupt
+                            && !current_function_trap);
 
   /* Get the scratch register to build the frame and push registers.
      If the first argument is a 32-bit quantity, the D+X registers
@@ -2014,6 +2240,14 @@ m68hc11_gen_highpart (mode, x)
 	{
 	  return gen_int_mode (val >> 16, HImode);
 	}
+      else if (mode == SImode)
+       {
+#if HOST_BITS_PER_WIDE_INT > 32
+         return gen_int_mode (val >> 32, SImode);
+#else
+         return (val >= 0) ? const0_rtx : constm1_rtx;
+#endif
+       }
     }
   if (mode == QImode && D_REG_P (x))
     return gen_rtx (REG, mode, HARD_A_REGNUM);
@@ -2307,7 +2541,21 @@ print_operand (file, op, letter)
 	    abort ();
 	  break;
 
+        case MEM:
+          if (TARGET_M6812)
+            {
+              fprintf (file, "[");
+              print_operand_address (file, XEXP (base, 0));
+              fprintf (file, "]");
+            }
+          else
+            abort ();
+          break;
+
 	default:
+          if (m68hc11_page0_symbol_p (base))
+            fprintf (file, "*");
+
 	  output_address (base);
 	  break;
 	}
@@ -2349,7 +2597,7 @@ print_operand (file, op, letter)
 }
 
 /* Returns true if the operand 'op' must be printed with parenthesis
-   arround it.  This must be done only if there is a symbol whose name
+   around it.  This must be done only if there is a symbol whose name
    is a processor register.  */
 static int
 must_parenthesize (op)
@@ -2903,15 +3151,7 @@ m68hc11_split_move (to, from, scratch)
   high_to = m68hc11_gen_highpart (mode, to);
 
   low_from = m68hc11_gen_lowpart (mode, from);
-  if (mode == SImode && GET_CODE (from) == CONST_INT)
-    {
-      if (INTVAL (from) >= 0)
-	high_from = const0_rtx;
-      else
-	high_from = constm1_rtx;
-    }
-  else
-    high_from = m68hc11_gen_highpart (mode, from);
+  high_from = m68hc11_gen_highpart (mode, from);
 
   if (offset)
     {
@@ -3104,26 +3344,8 @@ m68hc11_split_logical (mode, code, opera
   low[2] = m68hc11_gen_lowpart (mode, operands[2]);
 
   high[0] = m68hc11_gen_highpart (mode, operands[0]);
-
-  if (mode == SImode && GET_CODE (operands[1]) == CONST_INT)
-    {
-      if (INTVAL (operands[1]) >= 0)
-	high[1] = const0_rtx;
-      else
-	high[1] = constm1_rtx;
-    }
-  else
-    high[1] = m68hc11_gen_highpart (mode, operands[1]);
-
-  if (mode == SImode && GET_CODE (operands[2]) == CONST_INT)
-    {
-      if (INTVAL (operands[2]) >= 0)
-	high[2] = const0_rtx;
-      else
-	high[2] = constm1_rtx;
-    }
-  else
-    high[2] = m68hc11_gen_highpart (mode, operands[2]);
+  high[1] = m68hc11_gen_highpart (mode, operands[1]);
+  high[2] = m68hc11_gen_highpart (mode, operands[2]);
 
   low[3] = operands[3];
   high[3] = operands[3];
@@ -3236,10 +3458,13 @@ m68hc11_gen_movhi (insn, operands)
 
   if (TARGET_M6812)
     {
-      if (IS_STACK_PUSH (operands[0]) && H_REG_P (operands[1]))
+      rtx from = operands[1];
+      rtx to = operands[0];
+
+      if (IS_STACK_PUSH (to) && H_REG_P (from))
 	{
           cc_status = cc_prev_status;
-	  switch (REGNO (operands[1]))
+	  switch (REGNO (from))
 	    {
 	    case HARD_X_REGNUM:
 	    case HARD_Y_REGNUM:
@@ -3247,17 +3472,17 @@ m68hc11_gen_movhi (insn, operands)
 	      output_asm_insn ("psh%1", operands);
 	      break;
             case HARD_SP_REGNUM:
-              output_asm_insn ("sts\t-2,sp", operands);
+              output_asm_insn ("sts\t2,-sp", operands);
               break;
 	    default:
 	      abort ();
 	    }
 	  return;
 	}
-      if (IS_STACK_POP (operands[1]) && H_REG_P (operands[0]))
+      if (IS_STACK_POP (from) && H_REG_P (to))
 	{
           cc_status = cc_prev_status;
-	  switch (REGNO (operands[0]))
+	  switch (REGNO (to))
 	    {
 	    case HARD_X_REGNUM:
 	    case HARD_Y_REGNUM:
@@ -3278,17 +3503,6 @@ m68hc11_gen_movhi (insn, operands)
 	{
 	  if (SP_REG_P (operands[0]))
 	    output_asm_insn ("lds\t%1", operands);
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && !D_REG_P (operands[0])
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("in%0", operands);
-              else
-                output_asm_insn ("de%0", operands);
-            }
 	  else
 	    output_asm_insn ("ld%0\t%1", operands);
 	}
@@ -3299,11 +3513,59 @@ m68hc11_gen_movhi (insn, operands)
 	  else
 	    output_asm_insn ("st%1\t%0", operands);
 	}
+
+      /* The 68hc12 does not support (MEM:HI (MEM:HI)) with the movw
+         instruction.  We have to use a scratch register as temporary location.
+         Trying to use a specific pattern or constrain failed.  */
+      else if (GET_CODE (to) == MEM && GET_CODE (XEXP (to, 0)) == MEM)
+        {
+          rtx ops[4];
+
+          ops[0] = to;
+          ops[2] = from;
+          ops[3] = 0;
+          if (dead_register_here (insn, d_reg))
+            ops[1] = d_reg;
+          else if (dead_register_here (insn, ix_reg))
+            ops[1] = ix_reg;
+          else if (dead_register_here (insn, iy_reg))
+            ops[1] = iy_reg;
+          else
+            {
+              ops[1] = d_reg;
+              ops[3] = d_reg;
+              output_asm_insn ("psh%3", ops);
+            }
+
+          ops[0] = to;
+          ops[2] = from;
+          output_asm_insn ("ld%1\t%2", ops);
+          output_asm_insn ("st%1\t%0", ops);
+          if (ops[3])
+            output_asm_insn ("pul%3", ops);
+        }
+
+      /* Use movw for non-null constants or when we are clearing
+         a volatile memory reference.  However, this is possible
+         only if the memory reference has a small offset or is an
+         absolute address.  */
+      else if (GET_CODE (from) == CONST_INT
+               && INTVAL (from) == 0
+               && (MEM_VOLATILE_P (to) == 0
+                   || m68hc11_small_indexed_indirect_p (to, HImode) == 0))
+        {
+          if (TARGET_M68S12X)
+          {
+            output_asm_insn ("clrw\t%0", operands);
+          }
+          else
+          {
+          output_asm_insn ("clr\t%h0", operands);
+          output_asm_insn ("clr\t%b0", operands);
+          }
+        }
       else
 	{
-	  rtx from = operands[1];
-	  rtx to = operands[0];
-
 	  if ((m68hc11_register_indirect_p (from, GET_MODE (from))
 	       && !m68hc11_small_indexed_indirect_p (from, GET_MODE (from)))
 	      || (m68hc11_register_indirect_p (to, GET_MODE (to))
@@ -3320,6 +3582,7 @@ m68hc11_gen_movhi (insn, operands)
 		  ops[0] = to;
 		  ops[1] = operands[2];
 		  m68hc11_gen_movhi (insn, ops);
+                  return;
 		}
 	      else
 		{
@@ -3327,19 +3590,11 @@ m68hc11_gen_movhi (insn, operands)
                   fatal_insn ("move insn not handled", insn);
 		}
 	    }
-	  else
-	    {
-	      if (GET_CODE (from) == CONST_INT && INTVAL (from) == 0)
-		{
-		  output_asm_insn ("clr\t%h0", operands);
-		  output_asm_insn ("clr\t%b0", operands);
-		}
-	      else
-		{
-                  m68hc11_notice_keep_cc (operands[0]);
-		  output_asm_insn ("movw\t%1,%0", operands);
-		}
-	    }
+          else
+            {
+              m68hc11_notice_keep_cc (operands[0]);
+              output_asm_insn ("movw\t%1,%0", operands);
+            }
 	}
       return;
     }
@@ -3472,16 +3727,6 @@ m68hc11_gen_movhi (insn, operands)
 	      cc_status = cc_prev_status;
 	      output_asm_insn ("tsx", operands);
 	    }
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("in%0", operands);
-              else
-                output_asm_insn ("de%0", operands);
-            }
 	  else
 	    {
 	      output_asm_insn ("ldx\t%1", operands);
@@ -3530,16 +3775,6 @@ m68hc11_gen_movhi (insn, operands)
 	      cc_status = cc_prev_status;
 	      output_asm_insn ("tsy", operands);
 	    }
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("in%0", operands);
-              else
-                output_asm_insn ("de%0", operands);
-            }
           else
 	    {
 	      output_asm_insn ("ldy\t%1", operands);
@@ -3689,8 +3924,10 @@ m68hc11_gen_movqi (insn, operands)
 	}
       else if (H_REG_P (operands[0]))
 	{
-	  if (Q_REG_P (operands[0]))
-	    output_asm_insn ("lda%0\t%b1", operands);
+          if (IS_STACK_POP (operands[1]))
+            output_asm_insn ("pul%b0", operands);
+	  else if (Q_REG_P (operands[0]))
+            output_asm_insn ("lda%0\t%b1", operands);
 	  else if (D_REG_P (operands[0]))
 	    output_asm_insn ("ldab\t%b1", operands);
 	  else
@@ -3780,16 +4017,6 @@ m68hc11_gen_movqi (insn, operands)
 		  output_asm_insn ("ldab\t%T0", operands);
 		}
 	    }
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("inc%b0", operands);
-              else
-                output_asm_insn ("dec%b0", operands);
-            }          
 	  else if (!DB_REG_P (operands[1]) && !D_REG_P (operands[1])
 		   && !DA_REG_P (operands[1]))
 	    {
@@ -3935,11 +4162,34 @@ m68hc11_gen_movqi (insn, operands)
 	  break;
 
 	case HARD_X_REGNUM:
-	  output_asm_insn ("xgdx\n\tstab\t%b0\n\txgdx", operands);
-	  break;
-
-	case HARD_Y_REGNUM:
-	  output_asm_insn ("xgdy\n\tstab\t%b0\n\txgdy", operands);
+        case HARD_Y_REGNUM:
+	  if (!reg_mentioned_p (operands[1], operands[0]))
+	    {
+              output_asm_insn ("xgd%1\n\tstab\t%b0\n\txgd%1", operands);
+            }
+          else if (TARGET_M6811)
+            {
+              int dead = dead_register_here (insn, d_reg);
+	      output_asm_insn ("st%1\t%t1", operands);
+              if (!dead)
+                output_asm_insn ("psha", operands);
+	      output_asm_insn ("ldaa\t%T1", operands);
+	      output_asm_insn ("staa\t%0", operands);
+              if (!dead)
+                output_asm_insn ("pula", operands);
+	      CC_STATUS_INIT;
+            }
+          else
+            {
+              int dead = dead_register_here (insn, d_reg);
+              if (!dead)
+                output_asm_insn ("psha", operands);
+	      output_asm_insn ("tfr\t%1,a", operands);
+	      output_asm_insn ("staa\t%0", operands);
+              if (!dead)
+                output_asm_insn ("pulb", operands);
+	      CC_STATUS_INIT;
+            }
 	  break;
 
 	default:
@@ -4136,6 +4386,12 @@ m68hc11_notice_update_cc (exp, insn)
       && cc_status.value2
       && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))
     cc_status.value2 = 0;
+
+  else if (cc_status.value1 && side_effects_p (cc_status.value1))
+    cc_status.value1 = 0;
+
+  else if (cc_status.value2 && side_effects_p (cc_status.value2))
+    cc_status.value2 = 0;
 }
 
 /* The current instruction does not affect the flags but changes
@@ -4306,8 +4562,10 @@ m68hc11_check_z_replacement (insn, info)
 	{
 	  if ((GET_CODE (src) == REG && REGNO (src) == HARD_Z_REGNUM)
 	      || (GET_CODE (src) == COMPARE &&
-		  (rtx_equal_p (XEXP (src, 0), z_reg)
-		   || rtx_equal_p (XEXP (src, 1), z_reg))))
+		  ((rtx_equal_p (XEXP (src, 0), z_reg)
+                    && H_REG_P (XEXP (src, 1)))
+		   || (rtx_equal_p (XEXP (src, 1), z_reg)
+                       && H_REG_P (XEXP (src, 0))))))
 	    {
 	      if (insn == info->first)
 		{
@@ -4905,7 +5163,7 @@ m68hc11_find_z_replacement (insn, info)
 /* The insn uses the Z register.  Find a replacement register for it
    (either X or Y) and replace it in the insn and the next ones until
    the flow changes or the replacement register is used.  Instructions
-   are emited before and after the Z-block to preserve the value of
+   are emitted before and after the Z-block to preserve the value of
    Z and of the replacement register.  */
 
 static void
@@ -5067,9 +5325,11 @@ m68hc11_z_replacement (insn)
       if (info.save_before_last)
 	save_pos_insn = PREV_INSN (save_pos_insn);
 
-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, SOFT_Z_REGNUM),
-				   gen_rtx (REG, HImode, info.regno)),
-			save_pos_insn);
+      /* Use emit_insn_after () to ensure the new insn is part of
+         the good basic block.  */
+      emit_insn_after (gen_movhi (gen_rtx (REG, HImode, SOFT_Z_REGNUM),
+                                  gen_rtx (REG, HImode, info.regno)),
+                       PREV_INSN (save_pos_insn));
     }
 
   if (info.must_push_reg && info.last)
@@ -5108,8 +5368,8 @@ m68hc11_z_replacement (insn)
       else
 	dst = gen_rtx (REG, HImode, SOFT_SAVED_XY_REGNUM);
 
-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, info.regno),
-				   dst), insn);
+      emit_insn_after (gen_movhi (gen_rtx (REG, HImode, info.regno),
+                                  dst), PREV_INSN (insn));
     }
 
 }
@@ -5176,6 +5436,13 @@ m68hc11_reassign_regs (first)
 }
 
 
+/* Machine-dependent reorg pass.
+   Specific optimizations are defined here:
+    - this pass changes the Z register into either X or Y
+      (it preserves X/Y previous values in a memory slot in page0).
+
+   When this pass is finished, the global variable
+   'z_replacement_completed' is set to 2.  */
 void
 m68hc11_reorg (first)
      rtx first;
@@ -5204,7 +5471,7 @@ m68hc11_reorg (first)
   z_replacement_completed = 1;
   m68hc11_reassign_regs (first);
 
-  /* After some splitting, there are some oportunities for CSE pass.
+  /* After some splitting, there are some opportunities for CSE pass.
      This happens quite often when 32-bit or above patterns are split.  */
   if (optimize > 0 && split_done)
     {
@@ -5355,7 +5622,7 @@ m68hc11_address_cost (addr)
       break;
 
     case SYMBOL_REF:
-      cost = 8;
+      cost = m68hc11_page0_symbol_p (addr) ? 0 : 8;
       break;
 
     case LABEL_REF:
@@ -5388,7 +5655,7 @@ m68hc11_address_cost (addr)
 	    break;
 
 	  case SYMBOL_REF:
-	    cost = 8;
+	    cost = m68hc11_page0_symbol_p (addr) ? 0 : 8;
 	    break;
 
 	  case CONST:
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m68hc11-crt0.S gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11-crt0.S
--- gcc-3.3.6/gcc/config/m68hc11/m68hc11-crt0.S	2016-12-11 19:32:34.670647776 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11-crt0.S	2016-12-11 19:32:40.894702914 +0100
@@ -79,7 +79,7 @@ _start:
 ;; 
 ;;	int __premain(void);
 ;; 
-	jsr	__premain
+	bsr	__premain
 	
 ;;
 ;; 
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m68hc11.h gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11.h
--- gcc-3.3.6/gcc/config/m68hc11/m68hc11.h	2016-12-11 19:32:34.674647811 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11.h	2016-12-11 19:32:40.898702949 +0100
@@ -1,22 +1,23 @@
 /* Definitions of target machine for GNU compiler.
    Motorola 68HC11 and 68HC12.
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004,
+   2005, 2006 Free Software Foundation, Inc.
    Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
-This file is part of GNU CC.
+This file is part of GCC.
 
-GNU CC is free software; you can redistribute it and/or modify
+GCC is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
 
-GNU CC is distributed in the hope that it will be useful,
+GCC is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with GNU CC; see the file COPYING.  If not, write to
+along with GCC; see the file COPYING.  If not, write to
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
 
@@ -41,24 +42,28 @@ Note:
 
 #undef ENDFILE_SPEC
 
-/* Compile and assemble for a 68hc11 unless there is a -m68hc12 option.  */
+/* Default to compile and assemble for a 68hc11 */
+/* convert parameter style from 'cc1' to 'as' */
 #ifndef ASM_SPEC
 #define ASM_SPEC                                                \
 "%{m68hc12:-m68hc12}"                                           \
 "%{m68hcs12:-m68hcs12}"                                         \
-"%{!m68hc12:%{!m68hcs12:-m68hc11}} "                            \
+"%{m9s12x:-mm9s12x}"                                             \
+"%{!m68hc12:%{!m68hcs12:%{!m9s12x:-m68hc11}}} "                 \
 "%{mshort:-mshort}%{!mshort:-mlong} "                           \
 "%{fshort-double:-mshort-double}%{!fshort-double:-mlong-double}"
 #endif
 
 /* We need to tell the linker the target elf format.  Just pass an
-   emulation option.  This can be overriden by -Wl option of gcc.  */
+   emulation option.  This can be overridden by -Wl option of gcc.  */
 #ifndef LINK_SPEC
 #define LINK_SPEC                                               \
 "%{m68hc12:-m m68hc12elf}"                                      \
 "%{m68hcs12:-m m68hc12elf}"                                     \
-"%{!m68hc12:%{!m68hcs12:-m m68hc11elf}} "                       \
-"%{!mnorelax:%{!m68hc12:%{!m68hcs12:-relax}}}"
+"%{m9s12x:-m m9s12x}"                                           \
+"%{!m68hc12:%{!m68hcs12:%{!m9s12x:-m m68hc11elf}}} "            \
+"%{!mnorelax:%{!m68hc12:%{!m68hcs12:%{!m9s12x:-relax}}}}"
+
 #endif
 
 #ifndef LIB_SPEC
@@ -75,7 +80,8 @@ Note:
  %{!mshort:-D__INT__=32}\
  %{m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}\
  %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hcs12}\
- %{!m68hc12:%{!m68hcs12:-Dmc6811 -DMC6811 -Dmc68hc11}}\
+ %{m9s12x:-Dmc6812 -DMC6812 -Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}\
+ %{!m68hc12:%{!m68hcs12:%{!m9s12x:-Dmc6811 -DMC6811 -Dmc68hc11}}}\
  %{fshort-double:-D__HAVE_SHORT_DOUBLE__}\
  %{mlong-calls:-D__USE_RTC__}"
 #endif
@@ -84,7 +90,9 @@ Note:
 #define STARTFILE_SPEC "crt1%O%s"
 
 /* Names to predefine in the preprocessor for this target machine.  */
-#define CPP_PREDEFINES		"-Dmc68hc1x"
+#ifndef CPP_PREDEFINES
+#define CPP_PREDEFINES		"-Dmc68hc1x -Dtarget11"
+#endif
 
 /* As an embedded target, we have no libc.  */
 #define inhibit_libc
@@ -125,20 +133,22 @@ extern short *reg_renumber;	/* def in lo
  * with -mauto-incdec.
  */
 
-#define MASK_SHORT              0002	/* Compile with 16-bit `int' */
-#define MASK_AUTO_INC_DEC       0004
-#define MASK_M6811              0010
-#define MASK_M6812              0020
-#define MASK_M68S12             0040
-#define MASK_NO_DIRECT_MODE     0100
-#define MASK_MIN_MAX            0200
-#define MASK_LONG_CALLS         0400
+#define MASK_SHORT              0x0002	/* Compile with 16-bit `int' */
+#define MASK_AUTO_INC_DEC       0x0004    /* FIXME - tidy M68XX flags order */
+#define MASK_M6811              0x0010
+#define MASK_M6812              0x0020
+#define MASK_M68S12             0x0040
+#define MASK_NO_DIRECT_MODE     0x0100
+#define MASK_MIN_MAX            0x0200
+#define MASK_LONG_CALLS         0x0400
+#define MASK_M68S12X            0x0800
 
 #define TARGET_OP_TIME		(optimize && optimize_size == 0)
 #define TARGET_SHORT            (target_flags & MASK_SHORT)
 #define TARGET_M6811            (target_flags & MASK_M6811)
 #define TARGET_M6812            (target_flags & MASK_M6812)
 #define TARGET_M68S12           (target_flags & MASK_M68S12)
+#define TARGET_M68S12X          (!(target_flags & MASK_M6811) && (target_flags & MASK_M68S12X)) 
 #define TARGET_AUTO_INC_DEC     (target_flags & MASK_AUTO_INC_DEC)
 #define TARGET_MIN_MAX          (target_flags & MASK_MIN_MAX)
 #define TARGET_NO_DIRECT_MODE   (target_flags & MASK_NO_DIRECT_MODE)
@@ -161,6 +171,7 @@ extern short *reg_renumber;	/* def in lo
 #  define MULTILIB_DEFAULTS { "m68hc12" }
 # endif
 #endif
+/* 9s12x in own .h */
 
 /* Macro to define tables used to set the flags. This is a list in braces of
    pairs in braces, each pair being { "NAME", VALUE } where VALUE is the bits
@@ -200,6 +211,10 @@ extern short *reg_renumber;	/* def in lo
     N_("Compile for a 68HC12")},				\
   { "68S12",  MASK_M6812 | MASK_M68S12,				\
     N_("Compile for a 68HCS12")},				\
+  { "9s12x",  MASK_M6812 | MASK_M68S12 | MASK_M68S12X,		\
+    N_("Compile for CPU12X")},				\
+  { "m9s12x",  MASK_M6812 | MASK_M68S12 | MASK_M68S12X,		\
+    N_("Compile for CPU12X")},				\
   { "", TARGET_DEFAULT, 0 }}
 
 /* This macro is similar to `TARGET_SWITCHES' but defines names of
@@ -232,7 +247,7 @@ extern const char *m68hc11_soft_reg_coun
 #endif
 
 /* Print subsidiary information on the compiler version in use.  */
-#define TARGET_VERSION	fprintf (stderr, " (MC68HC11/MC68HC12/MC68HCS12)")
+#define TARGET_VERSION	fprintf (stderr, " (MC68HC11/MC68HC12/MC68HCS12/M9S12X)")
 
 /* Sometimes certain combinations of command options do not make
    sense on a particular target machine.  You can define a macro
@@ -277,6 +292,10 @@ extern const struct processor_costs *m68
 /* Define this if most significant word of a multiword number is numbered.  */
 #define WORDS_BIG_ENDIAN 	1
 
+/* Use a MAX_BITS_PER_WORD equivalent to SImode so that
+   several SI patterns can be used (mostly shift & add).  */
+/* #define MAX_BITS_PER_WORD       32  */
+
 /* Width of a word, in units (bytes).  */
 #define UNITS_PER_WORD		2
 
@@ -804,8 +823,8 @@ extern enum reg_class m68hc11_tmp_regs_c
 /* A C expression that is nonzero if hard register number REGNO2 can be
    considered for use as a rename register for REGNO1 */
 
-#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) \
-  m68hc11_hard_regno_rename_ok ((REGNO1), (REGNO2))
+#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2,MODE)            \
+  m68hc11_hard_regno_rename_ok ((REGNO1), (REGNO2), (MODE))
 
 /* A C expression whose value is nonzero if pseudos that have been
    assigned to registers of class CLASS would likely be spilled
@@ -874,7 +893,9 @@ extern enum reg_class m68hc11_tmp_regs_c
 		 && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) 
 
 /* 'U' represents certain kind of memory indexed operand for 68HC12.
-   and any memory operand for 68HC11.  */
+   and any memory operand for 68HC11.
+   'R' represents indexed addressing mode or access to page0 for 68HC11.
+   For 68HC12, it represents any memory operand.  */
 #define EXTRA_CONSTRAINT(OP, C)                         \
 ((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) \
  : (C) == 'Q' ? m68hc11_symbolic_p (OP, GET_MODE (OP)) \
@@ -963,7 +984,7 @@ extern enum reg_class m68hc11_tmp_regs_c
    followed by "to".  Eliminations of the same "from" register are listed
    in order of preference.
 
-   We have two registers that are eliminated on the 6811. The psuedo arg
+   We have two registers that are eliminated on the 6811. The pseudo arg
    pointer and pseudo frame pointer registers can always be eliminated;
    they are replaced with either the stack or the real frame pointer.  */
 
@@ -1215,7 +1236,7 @@ extern enum reg_class m68hc11_index_reg_
 
 
 /* Internal macro, return 1 if REGNO is a valid base register.  */
-#define REG_VALID_P(REGNO) (1)	/* ? */
+#define REG_VALID_P(REGNO) ((REGNO) >= 0)
 
 extern unsigned char m68hc11_reg_valid_for_base[FIRST_PSEUDO_REGISTER];
 #define REG_VALID_FOR_BASE_P(REGNO) \
@@ -1489,7 +1510,7 @@ extern unsigned char m68hc11_reg_valid_f
    macro is used in only one place: `find_reloads_address' in reload.c.
 
    For M68HC11, we handle large displacements of a base register
-   by splitting the addend accors an addhi3 insn.
+   by splitting the addend across an addhi3 insn.
 
    For M68HC12, the 64K offset range is available.
    */
@@ -1690,7 +1711,7 @@ do {
 
 /* Assembler Commands for Exception Regions.  */
 
-/* Default values provided by GCC should be ok. Assumming that DWARF-2
+/* Default values provided by GCC should be ok. Assuming that DWARF-2
    frame unwind info is ok for this platform.  */
 
 #undef PREFERRED_DEBUGGING_TYPE
@@ -1719,6 +1740,12 @@ do {
 #define IMMEDIATE_PREFIX "#"
 #define GLOBAL_ASM_OP   "\t.globl\t"
 
+/* This is how to output a reference to a user-level label named NAME.
+   `assemble_name' uses this.  */
+#undef  ASM_OUTPUT_LABELREF
+#define ASM_OUTPUT_LABELREF(FILE, NAME) \
+  asm_fprintf (FILE, "%U%s", (*targetm.strip_name_encoding) (NAME))
+
 
 /* Miscellaneous Parameters.  */
 
@@ -1737,8 +1764,10 @@ do {
 {"m68hc11_shift_operator",   {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATE, ROTATERT}},\
 {"m68hc11_eq_compare_operator", {EQ, NE}},                              \
 {"non_push_operand",         {SUBREG, REG, MEM}},			\
+{"splitable_operand",        {SUBREG, REG, MEM}},			\
 {"reg_or_some_mem_operand",  {SUBREG, REG, MEM}},			\
 {"tst_operand",              {SUBREG, REG, MEM}},			\
+{"nonimmediate_noinc_operand", {SUBREG, REG, MEM}},			\
 {"cmp_operand",              {SUBREG, REG, MEM, SYMBOL_REF, LABEL_REF,	\
 			     CONST_INT, CONST_DOUBLE}},
 
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m68hc11.md gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11.md
--- gcc-3.3.6/gcc/config/m68hc11/m68hc11.md	2016-12-11 19:32:34.678647847 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11.md	2016-12-11 19:32:40.902702985 +0100
@@ -1,21 +1,22 @@
 ;;- Machine description file for Motorola 68HC11 and 68HC12.
-;;- Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+;;- Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+;;- Free Software Foundation, Inc.
 ;;- Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
-;; This file is part of GNU CC.
+;; This file is part of GCC.
 
-;; GNU CC is free software; you can redistribute it and/or modify
+;; GCC is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation; either version 2, or (at your option)
 ;; any later version.
 
-;; GNU CC is distributed in the hope that it will be useful,
+;; GCC is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU CC; see the file COPYING.  If not, write to
+;; along with GCC; see the file COPYING.  If not, write to
 ;; the Free Software Foundation, 59 Temple Place - Suite 330,
 ;; Boston, MA 02111-1307, USA.
 
@@ -93,7 +94,7 @@
 ;; Operands modifiers:
 ;;
 ;;     %b	Get the low part of the operand (to obtain a QImode)
-;;		This modified must always be used for QImode operations
+;;		This modifier must always be used for QImode operations
 ;;		because a correction must be applied when the operand
 ;;		is a soft register (ex: *ZD1). Otherwise, we generate
 ;;		*ZD1 and this is the high part of the register. For other
@@ -143,7 +144,9 @@
    (A_REGNUM        5)		; A (high part of D)
    (B_REGNUM        6)		; B (low part of D)
    (CC_REGNUM       7)		; Condition code register
-   (SOFT_Z_REGNUM  11)          ; Z soft register
+   (SOFT_TMP_REGNUM 10)         ; TMP soft register
+   (SOFT_Z_REGNUM   11)         ; Z soft register
+   (SOFT_XY_REGNUM  12)         ; XY soft register
 ])
 
 ;;--------------------------------------------------------------------
@@ -192,6 +195,20 @@
      return \"cp%0\\t#0\";
 }")
 
+(define_insn "tsthi_1_s12x"
+  [(set (cc0)
+	(match_operand:HI 0 "tst_operand" "dx,*y"))]
+  "TARGET_M68S12X"
+  "*
+{
+   if (D_REG_P (operands[0]) && !TARGET_M6812)
+     return \"std\\t%t0\";
+   else if (X_REG_P (operands[0]) || Y_REG_P (operands[0]))
+     return \"tst%0\";
+   else
+     return \"cp%0\\t#0\";
+}")
+
 (define_expand "tstqi"
   [(set (cc0)
 	(match_operand:QI 0 "tst_operand" ""))]
@@ -247,19 +264,13 @@
 ;; avoid problems with the flow+cse register pass which are made
 ;; after Z register replacement.
 ;;
-(define_insn "tstqi_z_used"
+(define_insn_and_split "tstqi_z_used"
   [(set (cc0)
 	(match_operand:QI 0 "tst_operand" "m"))
    (use (match_operand:HI 1 "hard_reg_operand" "dxy"))
-   (use (reg:HI 11))]
-  ""
-  "#")
-
-(define_split /* "tstqi_z_used" */
-  [(set (cc0)
-	(match_operand:QI 0 "tst_operand" ""))
-   (use (match_operand:HI 1 "hard_reg_operand" ""))
    (use (reg:HI SOFT_Z_REGNUM))]
+  ""
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))
    (set (match_dup 1) (match_dup 2))
@@ -300,12 +311,24 @@
   [(set (cc0)
 	(compare (match_operand:HI 0 "hard_reg_operand" "")
 		 (match_operand:HI 1 "hard_reg_operand" "")))]
-  "reload_completed"
+  "TARGET_M6811
+   && reload_completed && !(Z_REG_P (operands[0]) || Z_REG_P (operands[1]))"
   [(set (match_dup 2) (match_dup 1))
    (set (cc0)
         (compare (match_dup 0) (match_dup 2)))]
   "operands[2] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);")
 
+(define_split
+  [(set (cc0)
+	(compare (match_operand:HI 0 "hard_reg_operand" "")
+		 (match_operand:HI 1 "hard_reg_operand" "")))]
+  "0 && TARGET_M6812
+   && reload_completed && !(Z_REG_P (operands[0]) || Z_REG_P (operands[1]))"
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))
+   (set (cc0)
+        (compare (match_dup 0) (mem:HI (post_inc:HI (reg:HI SP_REGNUM)))))]
+  "")
+
 (define_expand "cmphi"
   [(set (cc0)
 	(compare (match_operand:HI 0 "tst_operand" "")
@@ -325,7 +348,7 @@
   [(set (cc0)
 	(compare (match_operand:HI 0 "tst_operand" 
 				"d,?xy,xyd,?xy,d,m,!u,dxy,dxy")
-		 (match_operand:HI 1 "cmp_operand"
+		 (match_operand:HI 1 "general_operand"
 				"i,i,!u,m,m,dxy,dxy,?*d*A,!*w")))]
   "TARGET_M6812"
   "*
@@ -335,8 +358,10 @@
       cc_status.flags |= CC_REVERSED;
       return \"cp%1\\t%0\";
     }
+  else if (SP_REG_P (operands[1]))
+    return \"sts\\t2,-sp\n\\tcp%0\\t2,sp+\";
   else if (H_REG_P (operands[1]))
-    return \"#\";
+    return \"psh%1\n\\tcp%0\\t2,sp+\";
   else
     return \"cp%0\\t%1\";
 }")
@@ -344,9 +369,9 @@
 (define_insn "cmphi_1_hc11"
   [(set (cc0)
 	(compare (match_operand:HI 0 "tst_operand" 
-				"dx,y,xyd,?xy,d,m,!u,dxy,dxy")
+				"dx,y,xyd,?xy,d,m,m,dxy,dxy,?u*z,dxy,*z")
 		 (match_operand:HI 1 "cmp_operand"
-				"i,i,!u,m,m,dxy,dxy,?*d*A,!*w")))]
+				"i,i,!u,m,m,?xy,d,?*d*A,?u,dxy,!*w,i")))]
   "TARGET_M6811"
   "*
 {
@@ -361,21 +386,14 @@
     return \"cp%0\\t%1\";
 }")
 
-(define_insn "cmphi_z_used"
+(define_insn_and_split "cmphi_z_used"
   [(set (cc0)
 	(compare (match_operand:HI 0 "tst_operand" "dxy,m")
-		 (match_operand:HI 1 "cmp_operand" "m,dxy")))
+		 (match_operand:HI 1 "cmp_operand" "mi,dxy")))
    (use (match_operand:HI 2 "hard_reg_operand" "dxy,dxy"))
    (use (reg:HI SOFT_Z_REGNUM))]
   ""
-  "#")
-  
-(define_split /* "cmphi_z_used" */
-  [(set (cc0)
-	(compare (match_operand:HI 0 "tst_operand" "")
-		 (match_operand:HI 1 "cmp_operand" "")))
-   (use (match_operand:HI 2 "hard_reg_operand" ""))
-   (use (reg:HI SOFT_Z_REGNUM))]
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))
    (set (match_dup 2) (match_dup 3))
@@ -452,21 +470,14 @@
    operands[3] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);
    operands[4] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);")
 
-(define_insn "bitcmpqi_z_used"
+(define_insn_and_split "bitcmpqi_z_used"
   [(set (cc0)
 	(and:QI (match_operand:QI 0 "tst_operand" "d,m")
 		(match_operand:QI 1 "cmp_operand" "m,d")))
    (use (match_operand:HI 2 "hard_reg_operand" "xy,xy"))
    (use (reg:HI SOFT_Z_REGNUM))]
   ""
-  "#")
-  
-(define_split /* "bitcmpqi_z_used" */
-  [(set (cc0)
-	(and:QI (match_operand:QI 0 "tst_operand" "")
-		(match_operand:QI 1 "cmp_operand" "")))
-   (use (match_operand:HI 2 "hard_reg_operand" ""))
-   (use (reg:HI SOFT_Z_REGNUM))]
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))
    (set (match_dup 2) (match_dup 3))
@@ -542,21 +553,14 @@
    return \"cmpb\\t%b0\";
 }")
 
-(define_insn "cmpqi_z_used"
+(define_insn_and_split "cmpqi_z_used"
   [(set (cc0)
 	(compare (match_operand:QI 0 "tst_operand" "dxy,m")
 		 (match_operand:QI 1 "cmp_operand" "m,dxy")))
    (use (match_operand:HI 2 "hard_reg_operand" "dxy,dxy"))
    (use (reg:HI SOFT_Z_REGNUM))]
   ""
-  "#")
-  
-(define_split /* cmpqi_z_used */
-  [(set (cc0)
-	(compare (match_operand:QI 0 "tst_operand" "")
-		 (match_operand:QI 1 "cmp_operand" "")))
-   (use (match_operand:HI 2 "hard_reg_operand" ""))
-   (use (reg:HI SOFT_Z_REGNUM))]
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))
    (set (match_dup 2) (match_dup 3))
@@ -573,41 +577,29 @@
 ;; (strict_low_part ...) information.  This is correct for our machine
 ;; description but not for GCC optimization passes.
 ;;
-(define_insn "movstrictsi"
+(define_insn_and_split "movstrictsi"
   [(set (strict_low_part (match_operand:SI 0 "non_push_operand" "+um,D,D"))
 	(match_operand:SI 1 "general_operand" "D,Dim,uD"))]
   ""
-  "#")
-
-(define_split
-  [(set (strict_low_part (match_operand:SI 0 "non_push_operand" ""))
-	(match_operand:SI 1 "general_operand" ""))]
+  "#"
   "z_replacement_completed == 2"
   [(set (match_dup 0) (match_dup 1))]
   "")
 
-(define_insn "movstricthi"
+(define_insn_and_split "movstricthi"
   [(set (strict_low_part (match_operand:HI 0 "non_push_operand" "+um,dA,dA"))
 	(match_operand:HI 1 "general_operand" "dA,dAim,u"))]
   ""
-  "#")
-
-(define_split
-  [(set (strict_low_part (match_operand:HI 0 "non_push_operand" ""))
-	(match_operand:HI 1 "general_operand" ""))]
+  "#"
   "z_replacement_completed == 2"
   [(set (match_dup 0) (match_dup 1))]
   "")
 
-(define_insn "movstrictqi"
+(define_insn_and_split "movstrictqi"
   [(set (strict_low_part (match_operand:QI 0 "non_push_operand" "+mu,!dA"))
 	(match_operand:QI 1 "general_operand" "d,imudA"))]
   ""
-  "#")
-
-(define_split
-  [(set (strict_low_part (match_operand:QI 0 "non_push_operand" ""))
-	(match_operand:QI 1 "general_operand" ""))]
+  "#"
   "z_replacement_completed == 2"
   [(set (match_dup 0) (match_dup 1))]
   "")
@@ -651,17 +643,26 @@
     }
 ")
 
-(define_insn "movdi_internal"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=ou,U,!u,U,m,m,!u")
+;; Separate push from normal moves to avoid reloading problems
+;; The 'clr' is not able to push on 68HC11 so we really need a scratch.
+;; We can also accept more scratch registers.
+(define_insn_and_split "*pushdi_internal"
+  [(set (match_operand:DI 0 "push_operand" "=<,<,<,<")
+	(match_operand:DI 1 "general_operand" "i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=&dA,&d,&d,&dA"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn_and_split "movdi_internal"
+  [(set (match_operand:DI 0 "non_push_operand" "=m!u,U,!u,U,m,m,!u")
 	(match_operand:DI 1 "general_operand" "K,iU,iU,!u,mi,!u,!mu"))
    (clobber (match_scratch:HI 2 "=X,&d,&d,&d,&d,&d,&d"))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(match_operand:DI 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -687,17 +688,24 @@
     }
 ")
 
-(define_insn "movdf_internal"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=ou,U,!u,U,m,m,!u")
+;; See pushdi_internal
+(define_insn_and_split "*pushdf_internal"
+  [(set (match_operand:DF 0 "push_operand" "=<,<,<,<")
+	(match_operand:DF 1 "general_operand" "i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=&dA,&d,&d,&dA"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn_and_split "movdf_internal"
+  [(set (match_operand:DF 0 "non_push_operand" "=mu,U,!u,U,m,m,!u")
 	(match_operand:DF 1 "general_operand" "G,iU,iU,!u,mi,!u,!mu"))
    (clobber (match_scratch:HI 2 "=X,&d,&d,&d,&d,&d,&d"))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:DF 0 "nonimmediate_operand" "")
-	(match_operand:DF 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -732,17 +740,23 @@
     }
 ")
 
-(define_insn "movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=ou,mu,?D,m,?D,?u,?u,!u,D")
-	(match_operand:SI 1 "general_operand"      "K,imu,im,?D,!u,?D,mi,!u,!D"))
-   (clobber (match_scratch:HI 2                    "=X,&d,X,X,X,X,&d,&d,X"))]
+(define_insn_and_split "*pushsi_internal"
+  [(set (match_operand:SI 0 "push_operand" "=<,<,<,<,<")
+	(match_operand:SI 1 "general_operand" "!D,i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=X,&dA,&d,&d,&dA"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
 
-(define_split
-  [(set (match_operand:SI 0 "nonimmediate_operand" "")
-	(match_operand:SI 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+(define_insn_and_split "movsi_internal"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=mu,mu,?D,m,?D,?u,?u,!u,D")
+	(match_operand:SI 1 "general_operand" "K,imu,im,?D,!u,?D,mi,!u,!D"))
+   (clobber (match_scratch:HI 2               "=X,&d,X,X,X,X,&d,&d,X"))]
+  ""
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -768,17 +782,23 @@
     }
 ")
 
-(define_insn "movsf_internal"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=o!u,m,D,m,D,!u,!u,!u,D")
+(define_insn_and_split "*pushsf_internal"
+  [(set (match_operand:SF 0 "push_operand" "=<,<,<,<,<")
+	(match_operand:SF 1 "general_operand" "!D,i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=X,&dA,&d,&d,&dA"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn_and_split "movsf_internal"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=m!u,m,D,m,D,!u,!u,!u,D")
 	(match_operand:SF 1 "general_operand" "G,im,im,D,!u,D,mi,!u,!D"))
    (clobber (match_scratch:HI 2 "=X,&d,X,X,X,X,&d,&d,X"))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:SF 0 "nonimmediate_operand" "")
-	(match_operand:SF 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -790,6 +810,17 @@
 ;; We don't need a scratch register.
 ;;--------------------------------------------------------------------
 
+(define_insn "movhi_const0_s12x"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,x,y,A,um")
+	(const_int 0))]
+  "TARGET_M68S12X"
+  "@
+   clra\\n\\tclrb
+   clrx
+   clry
+   ld%0\\t#0
+   clrw\\t%0")
+
 (define_insn "*movhi2_push"
   [(set (match_operand:HI 0 "push_operand" "=<,<,<")
 	(match_operand:HI 1 "general_operand" "xy,?d,!z"))]
@@ -849,6 +880,18 @@
           DONE;
         }
     }
+
+  /* The doloop optimization can emit a move with a constant > 32767.
+     This will fail later on because the move instruction is not recognized
+     eg: (set (reg:HI 53) (const_int 0x8000))
+     because for some reason gcc expects the constant to be sign extended
+     ie, it only recognize: (set (reg:HI 53) (const_int 0xffff8000))
+     Do the sign extension here.  */
+  if (GET_CODE (operands[1]) == CONST_INT
+      && INTVAL (operands[1]) > 0x7fffL && INTVAL (operands[1]) <= 0x0ffffL)
+    {
+      operands[1] = GEN_INT ((INTVAL (operands[1])) | (-1L << 16));
+    }
   if (TARGET_M6811 && (reload_in_progress | reload_completed) == 0)
     {
       if (GET_CODE (operands[0]) == MEM &&
@@ -878,18 +921,9 @@
     }
 }")
 
-(define_insn "movhi_const0"
-  [(set (match_operand:HI 0 "non_push_operand" "=d,A,um")
-	(const_int 0))]
-  ""
-  "@
-   clra\\n\\tclrb
-   ld%0\\t#0
-   clr\\t%b0\\n\\tclr\\t%h0")
-
 (define_insn "*movhi_68hc12"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=U,dAw,U,U,m,!u")
-	(match_operand:HI 1 "general_operand" "U,rim,dAwi,!u,dAw,riU"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=U,dAw,dAw,m,U,U,m,!u")
+	(match_operand:HI 1 "general_operand" "U,dAwim,!u,K,dAwi,!u,dAw,riU"))]
   "TARGET_M6812"
   "*
 {
@@ -897,6 +931,15 @@
   return \"\";
 }")
 
+(define_insn "movhi_const0"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,A,um")
+	(const_int 0))]
+  "TARGET_M6811"
+  "@
+   clra\\n\\tclrb
+   ld%0\\t#0
+   clr\\t%b0\\n\\tclr\\t%h0")
+
 (define_insn "*movhi_m68hc11"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=dAw,!u,m,m,dAw,!*u")
 	(match_operand:HI 1 "general_operand" "dAwim,dAw,dA,?Aw,!*u,dAw"))]
@@ -936,9 +979,9 @@
 (define_split
   [(set (match_operand:QI 0 "hard_addr_reg_operand" "")
         (match_operand:QI 1 "general_operand" ""))]
-  "z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode
+  "z_replacement_completed == 2
    && !reg_mentioned_p (operands[0], operands[1])
-   && !D_REG_P (operands[1])"
+   && !(D_REG_P (operands[1]) || Q_REG_P (operands[1]))"
   [(parallel [(set (reg:HI D_REGNUM) (match_dup 2))
               (set (match_dup 2) (reg:HI D_REGNUM))])
    (set (reg:QI D_REGNUM) (match_dup 1))
@@ -952,9 +995,9 @@
 (define_split
   [(set (match_operand:QI 0 "nonimmediate_operand" "")
         (match_operand:QI 1 "hard_addr_reg_operand" ""))]
-  "z_replacement_completed == 2 && GET_MODE (operands[1]) == QImode
+  "z_replacement_completed == 2
    && !reg_mentioned_p (operands[1], operands[0])
-   && !D_REG_P (operands[0])"
+   && !(D_REG_P (operands[0]) || Q_REG_P (operands[0]))"
   [(parallel [(set (reg:HI D_REGNUM) (match_dup 2))
               (set (match_dup 2) (reg:HI D_REGNUM))])
    (set (match_dup 0) (reg:QI D_REGNUM))
@@ -1664,8 +1707,8 @@
 ;;- Min and Max instructions (68HC12).
 ;;--------------------------------------------------------------------
 (define_insn "uminqi3"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m")
-	(umin:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umin:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:QI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1686,8 +1729,8 @@
 }")
 
 (define_insn "umaxqi3"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m")
-	(umax:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umax:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:QI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1708,8 +1751,8 @@
 }")
 
 (define_insn "uminhi3"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
-	(umin:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:HI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umin:HI (match_operand:HI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:HI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1727,8 +1770,8 @@
 }")
 
 (define_insn "umaxhi3"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
-	(umax:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:HI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umax:HI (match_operand:HI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:HI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1913,6 +1956,7 @@
   const char* inc_insn;
   const char* incb_mem;
   const char* inch_mem;
+  const char* incw_mem;
   HOST_WIDE_INT val;
 
   if (which_alternative > 2)
@@ -1925,11 +1969,19 @@
     {
       if (!H_REG_P (operands[0]))
 	{
+        if ((val == 0x1000) && TARGET_M68S12X)
+          {
+	  ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
+	  output_asm_insn (\"incw\\t%0\", ops);
+          }
+        else
+          {
 	  ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
 	  ops[1] = m68hc11_gen_highpart (HImode, operands[2]);
 	  output_asm_insn (\"ldd\\t%0\", ops);
 	  output_asm_insn (\"addd\\t%1\", ops);
 	  output_asm_insn (\"std\\t%0\", ops);
+          }
 	  return \"\";
 	}
       else if (val == 1)
@@ -1943,7 +1995,36 @@
     }
   if ((val & 0xffff0000L) != 0 && (val & 0xffff0000L) != 0xffff0000L)
     {
+      if (!H_REG_P (operands[0]) && TARGET_M68S12X)
+	    {
+  	      output_asm_insn (\";val high byte non-zero\", ops);
+	      ops[0] = m68hc11_gen_lowpart (HImode, operands[0]);
+	      ops[1] = m68hc11_gen_lowpart (HImode, operands[2]);
+	      output_asm_insn (\"ldd\\t%0\", ops);
+	      output_asm_insn (\"addd\\t%1\", ops);
+	      output_asm_insn (\"std\\t%0\", ops);
+	      ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
+	      ops[1] = m68hc11_gen_highpart (HImode, operands[2]);
+	      output_asm_insn (\"ldx\\t%0\", ops);
+	      output_asm_insn (\"adex\\t%1\", ops);
+	CC_STATUS_INIT; /* not sure if this is correct, but want to declare CC is not as expected after ADEX */
+	      output_asm_insn (\"stx\\t%0\", ops);
+	      return \"\";
+        }
+      else if (D_REG_P (operands[0]) && TARGET_M68S12X)
+        {
+  	      output_asm_insn (\";val high byte non-zero and D reg\", ops);
+	      ops[0] = m68hc11_gen_lowpart (HImode, operands[2]);
+	      ops[1] = m68hc11_gen_highpart (HImode, operands[2]);
+	      output_asm_insn (\"addd\\t%0\", ops);
+	      output_asm_insn (\"adex\\t%1\", ops);
+	CC_STATUS_INIT; /* not sure if this is correct, but want to declare CC is not as expected after ADEX */
+	      return \"\";
+        }
+      else
+        {
       return \"#\";
+        }
     }
 
   if (val >= 0)
@@ -1953,6 +2034,7 @@
       inc_insn = \"inx\\t\";
       incb_mem  = \"inc\\t%b1\";
       inch_mem  = \"inc\\t%h1\";
+      incw_mem  = \"incw\\t%1\";
     }
   else
     {
@@ -1961,6 +2043,7 @@
       inc_insn = \"dex\";
       incb_mem  = \"dec\\t%b1\";
       inch_mem  = \"dec\\t%h1\";
+      incw_mem  = \"decw\\t%1\";
     }
       
   ops[2] = gen_label_rtx ();
@@ -1985,16 +2068,30 @@
       ops[1] = ops[0];
       if (INTVAL (operands[2]) < 0)
 	{
+        if (TARGET_M68S12X)
+          {
+	  output_asm_insn (\"decw\\t%1\", ops);
+          }
+        else
+          {
 	  output_asm_insn (\"ldd\\t%1\", ops);
 	  output_asm_insn (\"addd\\t#-1\", ops);
 	  output_asm_insn (\"std\\t%1\", ops);
+          }
 	}
       else
 	{
+        if (TARGET_M68S12X)
+          {
+          output_asm_insn (incw_mem, ops);
+          }
+        else
+	  {
           output_asm_insn (incb_mem, ops);
           output_asm_insn (\"bne\\t%l2\", ops);
           output_asm_insn (inch_mem, ops);
-	}
+	  }
+        }
     }
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (ops[2]));
 
@@ -2002,6 +2099,11 @@
   return \"\";
 }")
 
+;;
+;;  split to handle 32-add when low-byte is zero
+;;
+;;
+
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
 	(plus:SI (match_operand:SI 1 "register_operand" "")
@@ -2024,6 +2126,33 @@
      }
    ")
 
+;;
+;;  split 32-bit D/X pair add into a HI add in D and an HI adc in X
+;;  S12X only 
+;;
+;; DISABLED - generates bad code
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_operand:SI 1 "register_operand" "")
+		 (match_operand:SI 2 "general_operand" "")))
+   (clobber (match_scratch:HI 3 "=X"))]
+  "TARGET_M68S12X && reload_completed && z_replacement_completed == 2 && 0
+    && (GET_CODE (operands[2]) != CONST_INT || 
+        (!(INTVAL (operands[2]) >= -65536 && INTVAL (operands[2]) <= 65535)))"
+  [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))
+   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI CC_REGNUM) (reg:HI X_REGNUM) )(match_dup 4)))]	
+
+  "operands[3] = m68hc11_gen_lowpart (HImode, operands[2]);
+   operands[4] = m68hc11_gen_highpart (HImode, operands[2]);")
+
+
+
+;; 
+;;  split 32-bit D/X pair add into a HI add in D , xg and a QI adc in A and B then another xg
+;;
+;;
+
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
 	(plus:SI (match_operand:SI 1 "register_operand" "")
@@ -2089,17 +2218,21 @@
     }
 }")
 
-(define_insn "*addhi3_68hc12"
-  [(set (match_operand:HI 0 "register_operand" "=xyd,d,xy*z*w,xy*z*w,xy*z")
-        (plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,xy*zw,0")
-                 (match_operand:HI 2 "general_operand" "i,m*A*wu,id,id,!mu*A")))]
-  "TARGET_M6812"
+; This currently generates addx #aaaa when leax aaaa,x is smaller and faster
+; DISABLED
+(define_insn "*addhi3_68hcs12x"
+  [(set (match_operand:HI 0 "register_operand" "=xy,d,d,xy*A*w,xy*A*w,xy*A")
+        (plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,xy*Aw,0")
+                 (match_operand:HI 2 "general_operand" "Lim!*u,i,m*A*wu,id,id,!mu*A")))]
+  "TARGET_M6812 && TARGET_M68S12X && 0"
   "*
 {
   int val;
   const char* insn_code;
+  /*  printf (\"alternative %d, %d, %d\\n\", which_alternative, REGNO(operands[0]), REGNO(operands[2])) ;
+      fflush(stdout) ; */
 
-  if (which_alternative >= 4)
+  if (which_alternative >= 5)
     {
       if (A_REG_P (operands[2]))
         {
@@ -2108,9 +2241,12 @@
 	  output_asm_insn (\"lea%0 d,%0\", operands);
 	  return \"xgd%2\";
 	}
+/*       printf (\"bombing out\\n\") ;  */
       return \"#\";
+      
     }
 
+
   if (D_REG_P (operands[0]))
     {
       if (X_REG_P (operands[2]))
@@ -2128,13 +2264,23 @@
 	  return \"xgdy\";
 	}
       else if (SP_REG_P (operands[2]))
-	{
+	{	
 	  output_asm_insn (\"sts\\t%t0\", operands);
 	  return \"addd\\t%t0\";
 	}
       return \"addd\\t%2\";
     }
 
+  if ((X_REG_P(operands[0]) || Y_REG_P(operands[0]) ) &&
+      (which_alternative!=4)){
+     if( !D_REG_P(operands[2]) &&
+     	  !X_REG_P(operands[2]) && 
+	 !Y_REG_P(operands[2])) {
+/* 	     printf (\"add %d %d %d %d \\n\", which_alternative, REGNO(operands[0]),REGNO(operands[1]),REGNO(operands[2]) ); */
+	     return \"add%0\\t%2\";
+     }
+  }
+
   if (GET_CODE (operands[2]) == CONST_INT)
     val = INTVAL (operands[2]);
   else
@@ -2199,67 +2345,177 @@
   return \"\";
 }")
 
-;;
-;; Specific pattern to add to the stack pointer.
-;; We also take care of the clobbering of the IY register.
-;;
-(define_insn "addhi_sp"
-  [(set (match_operand:HI 0 "stack_register_operand" "=w,w,w,w")
-	  (plus:HI (match_operand:HI 1 "stack_register_operand" "%0,0,0,0")
-		   (match_operand:HI 2 "general_operand" "P,im,u,im")))
-   (clobber (match_scratch:HI 3 "=X,&y,&y,!&x"))]
-  "!TARGET_M6812"
+(define_insn "*addhi3_68hc12"
+  [(set (match_operand:HI 0 "register_operand" "=d*A,d,xy*A*w,xy*A*w,xy*A")
+        (plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,xy*Aw,0")
+                 (match_operand:HI 2 "general_operand" "i,m*A*wu,id,id,!mu*A")))]
+  "TARGET_M6812"
   "*
 {
-  HOST_WIDE_INT val;
+  int val;
+  const char* insn_code;
 
-  if (optimize && Y_REG_P (operands[3])
-      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))
-    operands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+  if (which_alternative >= 4)
+    {
+      if (A_REG_P (operands[2]))
+        {
+	  CC_STATUS_INIT;
+	  output_asm_insn (\"xgd%2\", operands);
+	  output_asm_insn (\"lea%0 d,%0\", operands);
+	  return \"xgd%2\";
+	}
+      return \"#\";
+    }
 
-  if (GET_CODE (operands[2]) == CONST_INT
-      && (val = INTVAL (operands[2])) != 0
-      && (CONST_OK_FOR_LETTER_P (val, 'P')
-	  || (val > 0 && val <= 8)))
+  if (D_REG_P (operands[0]))
     {
-      while (val > 1 || val < -1)
+      if (X_REG_P (operands[2]))
 	{
-	  if (val > 0)
-	    {
-	      if (!H_REG_P (operands[3]))
-		break;
-
-	      output_asm_insn (\"pul%3\", operands);
-	      val -= 2;
-	    }
-	  else
-	    {
-	      output_asm_insn (\"pshx\", operands);
-	      val += 2;
-	    }
+	  m68hc11_notice_keep_cc (operands[0]);
+	  output_asm_insn (\"xgdx\", operands);
+	  output_asm_insn (\"leax\\td,%2\", operands);
+	  return \"xgdx\";
 	}
-      while (val != 0)
+      else if (Y_REG_P (operands[2]))
 	{
-	  if (val > 0)
-	    {
-	      output_asm_insn (\"ins\", operands);
-	      val--;
-	    }
-	  else
-	    {
-	      output_asm_insn (\"des\", operands);
-	      val++;
-	    }
+	  m68hc11_notice_keep_cc (operands[0]);
+	  output_asm_insn (\"xgdy\", operands);
+	  output_asm_insn (\"leay\\td,%2\", operands);
+	  return \"xgdy\";
 	}
-      cc_status = cc_prev_status;
-      return \"\";
+      else if (SP_REG_P (operands[2]))
+	{
+	  output_asm_insn (\"sts\\t%t0\", operands);
+	  return \"addd\\t%t0\";
+	}
+      return \"addd\\t%2\";
     }
 
-  /* Need to transfer to SP to X/Y and then to D register.
-     Register X/Y is lost, this is specified by the (clobber) statement.  */
-  output_asm_insn (\"ts%3\", operands);
-  if (GET_CODE (operands[2]) == CONST_INT
-      && ((val = INTVAL (operands[2])) >= 0 && val < 0x100)
+  if (GET_CODE (operands[2]) == CONST_INT)
+    val = INTVAL (operands[2]);
+  else
+    val = 1000;
+
+  if ((val != -1 && val != 1) || !rtx_equal_p (operands[0], operands[1]))
+    {
+      m68hc11_notice_keep_cc (operands[0]);
+      switch (REGNO (operands[0]))
+	{
+	case HARD_X_REGNUM:
+	  return \"leax\\t%i2,%1\";
+
+	case HARD_Y_REGNUM:
+	  return \"leay\\t%i2,%1\";
+
+	case HARD_SP_REGNUM:
+	  return \"leas\\t%i2,%1\";
+
+	default:
+	  fatal_insn (\"Invalid operands in the instruction\", insn);
+	}
+    }
+  if (val > 0)
+    {
+      insn_code = X_REG_P (operands[0]) ? \"inx\"
+		: Y_REG_P (operands[0]) ? \"iny\" : \"ins\";
+    }
+  else
+    {
+      val  = -val;
+      insn_code = X_REG_P (operands[0]) ? \"dex\"
+		: Y_REG_P (operands[0]) ? \"dey\" : \"des\";
+    }
+
+  /* For X and Y increment, the flags are not complete. Only the Z flag
+     is updated. For SP increment, flags are not changed.  */
+  if (SP_REG_P (operands[0]))
+    {
+      cc_status = cc_prev_status; 
+      if (INTVAL (operands[2]) < 0)
+	{
+	  while (val > 2)
+	    {
+	      output_asm_insn (\"pshx\", operands);
+	      val -= 2;
+	    }
+	  if (val == 0)
+	    return \"\";
+	}     
+    }
+  else
+    {
+      CC_STATUS_INIT;
+    }
+
+  while (val)
+    {
+      output_asm_insn (insn_code, operands);
+      val--;
+    }
+  return \"\";
+}")
+
+;;
+;; Specific pattern to add to the stack pointer.
+;; We also take care of the clobbering of the IY register.
+;;
+(define_insn "addhi_sp"
+  [(set (match_operand:HI 0 "stack_register_operand" "=w,w,w,w")
+	  (plus:HI (match_operand:HI 1 "stack_register_operand" "%0,0,0,0")
+		   (match_operand:HI 2 "general_operand" "P,im,u,im")))
+   (clobber (match_scratch:HI 3 "=X,&y,&y,!&x"))]
+  "!TARGET_M6812"
+  "*
+{
+  HOST_WIDE_INT val;
+
+  if (optimize && Y_REG_P (operands[3])
+      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))
+    operands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (val = INTVAL (operands[2])) != 0
+      && (CONST_OK_FOR_LETTER_P (val, 'P')
+	  || (val > 0 && val <= 8)))
+    {
+      while (val > 1 || val < -1)
+	{
+	  if (val > 0)
+	    {
+	      if (!H_REG_P (operands[3]))
+		break;
+
+	      output_asm_insn (\"pul%3\", operands);
+	      val -= 2;
+	    }
+	  else
+	    {
+	      output_asm_insn (\"pshx\", operands);
+	      val += 2;
+	    }
+	}
+      while (val != 0)
+	{
+	  if (val > 0)
+	    {
+	      output_asm_insn (\"ins\", operands);
+	      val--;
+	    }
+	  else
+	    {
+	      output_asm_insn (\"des\", operands);
+	      val++;
+	    }
+	}
+      cc_status = cc_prev_status;
+      return \"\";
+    }
+
+  /* Need to transfer to SP to X/Y and then to D register.
+     Register X/Y is lost, this is specified by the (clobber) statement.  */
+  output_asm_insn (\"ts%3\", operands);
+  if (GET_CODE (operands[2]) == CONST_INT
+      && ((val = INTVAL (operands[2])) >= 0 && val < 0x100)
       && dead_register_here (insn, gen_rtx (REG, HImode, HARD_D_REGNUM)))
     {
       output_asm_insn (\"ldab\\t%2\", operands);
@@ -2268,9 +2524,18 @@
     }
   else
     {
-      output_asm_insn (\"xgd%3\", operands);
-      output_asm_insn (\"addd\\t%2\", operands);
-      output_asm_insn (\"xgd%3\", operands);
+      if (TARGET_M68S12X)
+        {
+          output_asm_insn (\";without xgd\", operands);
+          output_asm_insn (\"add%3\\t%2\", operands);
+        }
+      else
+        {
+          output_asm_insn (\";with xgd\", operands);
+        output_asm_insn (\"xgd%3\", operands);
+        output_asm_insn (\"addd\\t%2\", operands);
+        output_asm_insn (\"xgd%3\", operands);
+      }
     }
 
    /* The status flags correspond to the addd.  xgdy and tys do not
@@ -2279,9 +2544,9 @@
 }")
 
 (define_insn "*addhi3"
-  [(set (match_operand:HI 0 "hard_reg_operand" "=A,dA,d,!A,d*A,!d*A")
-	(plus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0,0,0")
-		 (match_operand:HI 2 "general_operand" "N,I,i,I,mi*A*d,!u*d*w")))]
+  [(set (match_operand:HI 0 "hard_reg_operand" "=A,dA,d,!A,d*A,d,!d*A")
+	(plus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0,0,0,0")
+		 (match_operand:HI 2 "general_operand" "N,I,i,I,mi*A*d,*u,!u*d*w")))]
   "TARGET_M6811"
   "*
 {
@@ -2374,7 +2639,7 @@
   [(set (match_operand:HI 0 "hard_reg_operand" "=A,d")
 	(plus:HI (zero_extend:HI 
 		     (match_operand:QI 1 "nonimmediate_operand" "d,um*A"))
-		 (match_operand:HI 2 "hard_reg_operand" "0,0")))]
+		 (match_operand:HI 2 "general_operand" "0,0")))]
   ""
   "*
 {
@@ -2401,8 +2666,8 @@
   "")
 
 (define_insn "addqi3"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=!d*rm,dq,!*A")
-        (plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=!d*rm,dq,!*A")
+        (plus:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "%0,0,0")
                  (match_operand:QI 2 "general_operand" "N,ium*A*d,ium*A*d")))]
   ""
   "*
@@ -2464,13 +2729,26 @@
 ;;
 ;; add with carry is used for 32-bit add.
 ;;
+(define_insn "*adcBx"
+  [(set (match_operand:HI 0 "register_operand" "=dxy")
+        (plus:HI (plus:HI (reg:HI CC_REGNUM)
+                           (match_operand:HI 1 "register_operand" "%0"))
+                  (match_operand:HI 2 "general_operand" "ium")))]
+  "TARGET_M68S12X && 0"
+  "*
+{
+  output_asm_insn (\"ade%0\\t%2\", operands);
+  CC_STATUS_INIT; /* Z bit doesn't behave as gcc expects - this doesn't help */
+  return \"\";
+}")
+
 (define_insn "*adcq"
   [(set (match_operand:QI 0 "register_operand" "=q")
         (plus:QI (plus:QI (reg:QI CC_REGNUM)
                           (match_operand:QI 1 "register_operand" "%0"))
                  (match_operand:QI 2 "general_operand" "ium")))]
   ""
-  "adc%0\\t%b2")
+  ";adcqi\\nadc%0\\t%b2")
 
 ;;--------------------------------------------------------------------
 ;;- Subtract instructions.
@@ -2489,7 +2767,7 @@
 ;; Subtract with a constant are handled by addsi3.
 ;;
 ;;
-;; - 32-bit Add.
+;; - 32-bit Subtract.
 ;;
 (define_expand "subsi3"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
@@ -2499,6 +2777,37 @@
   ""
   "")
 
+; this is register = value - soft_register ; works at times, but then causes ICE with addsi3 ?? DISABLED
+(define_insn "*subsi3_soft"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(minus:SI (match_operand:SI 1 "general_operand" "")
+		  (match_operand:SI 2 "register_operand" "u")))
+   (clobber (match_scratch:HI 3 "=X"))]
+  "0"
+  "*
+{
+    rtx ops[4];
+    ops[0] = m68hc11_gen_lowpart (HImode, operands[1]);
+    ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
+    ops[2] = m68hc11_gen_lowpart (HImode, operands[2]);
+    ops[3] = m68hc11_gen_highpart (HImode, operands[2]);
+  output_asm_insn (\"ldd\\t%0\", ops);
+  output_asm_insn (\"ldx\\t%1\", ops);
+  output_asm_insn (\"subd\\t%2\", ops);
+    if (TARGET_M68S12X)
+      {
+        output_asm_insn (\"sbex\\t%3\", ops);
+      }
+    else
+      {
+        output_asm_insn (\"xgdx\", ops);
+        output_asm_insn (\"sbcb\\t%b3\", ops);
+        output_asm_insn (\"sbca\\t%h3\", ops);
+        output_asm_insn (\"xgdx\", ops);
+      }
+  return \"\";
+}")
+
 (define_insn "*subsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,D,D,D,!u")
 	(minus:SI (match_operand:SI 1 "general_operand" "0,oi,0,!u,0")
@@ -2571,10 +2880,30 @@
   return \"\";
 }")
 
+;; split for S12X architecture, just like 32-bit add split above.
+;;
+;;
+;; DISABLED
+
+(define_split
+   [(set (match_operand:SI 0 "register_operand" "")
+ 	(minus:SI (match_operand:SI 1 "register_operand" "")
+ 		 (match_operand:SI 2 "general_operand" "")))
+    (clobber (match_scratch:HI 3 "=X"))]
+  "TARGET_M68S12X && reload_completed && z_replacement_completed == 2 && 0
+    && (GET_CODE (operands[2]) != CONST_INT || 
+        (!(INTVAL (operands[2]) >= -65536 && INTVAL (operands[2]) <= 65535)))"
+  [(set (reg:HI D_REGNUM) (minus:HI (reg:HI D_REGNUM) (match_dup 3)))
+   (set (reg:HI X_REGNUM) (minus:HI (minus:HI (reg:HI CC_REGNUM) (reg:HI X_REGNUM) )(match_dup 4)))]	
+
+  "operands[3] = m68hc11_gen_lowpart (HImode, operands[2]);
+   operands[4] = m68hc11_gen_highpart (HImode, operands[2]);")
+
 ;;
 ;; reg:HI 1 -> d	reg:QI 6 -> B
 ;; reg:QI 7 -> ccr      reg:QI 5 -> A
 ;;
+; this is register = register - value
 (define_split /* "*subsi3" */
   [(set (match_operand:SI 0 "register_operand" "")
 	(minus:SI (match_operand:SI 1 "register_operand" "")
@@ -2594,6 +2923,7 @@
    operands[5] = m68hc11_gen_highpart (QImode, operands[4]);
    operands[4] = m68hc11_gen_lowpart (QImode, operands[4]);")
 
+; this is register = value - hard_register
 (define_split /* "*subsi3" */
   [(set (match_operand:SI 0 "register_operand" "")
 	(minus:SI (match_operand:SI 1 "general_operand" "")
@@ -2680,9 +3010,16 @@
       if (save_x)
 	output_asm_insn (\"xgdx\", operands);
       output_asm_insn (\"tsx\", operands);
+      if (TARGET_M68S12X)
+        {
+          output_asm_insn (\"subx\\t%2\", operands);
+        }
+      else
+        {
       output_asm_insn (\"xgdx\", operands);
       output_asm_insn (\"subd\\t%2\", operands);
       output_asm_insn (\"xgdx\", operands);
+        }
 
       /* The status flags correspond to the addd. xgdx/y and tx/ys do not
          modify the flags.  */
@@ -2696,21 +3033,26 @@
   /* Need to transfer to SP to X,Y and then to D register.
      Register X,Y is lost, this is specified by the (clobber) statement.  */
   output_asm_insn (\"ts%3\", operands);
+      if (TARGET_M68S12X)
+        {
+          output_asm_insn (\"sub%3\\t%2\", operands);
+        }
+      else
+        {
   output_asm_insn (\"xgd%3\", operands);
   output_asm_insn (\"subd\\t%2\", operands);
   output_asm_insn (\"xgd%3\", operands);
-
+        }
    /* The status flags correspond to the addd. xgdx/y and tx/ys do not
       modify the flags.  */
   return \"t%3s\";
 }")
 
-
-(define_insn "*subhi3"
-  [(set (match_operand:HI 0 "register_operand" "=d,*A,d*A")
-	(minus:HI (match_operand:HI 1 "register_operand" "0,0,0")
-		  (match_operand:HI 2 "general_operand" "im*A*d,im*d*A,!u")))]
-  ""
+(define_insn "*subhi3_orig"
+  [(set (match_operand:HI 0 "register_operand" "=d,*A,d,*A")
+	(minus:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
+		  (match_operand:HI 2 "general_operand" "im*A*d,im*d*A,u,!u")))]
+  "!TARGET_M68S12X"
   "*
 {
   /* Adding to an address register or with another/same register
@@ -2721,9 +3063,32 @@
   return \"subd\\t%2\";
 }")
 
+(define_insn "*subhi3_x"
+; commented definition causes show-stoppingly bad bug of wrong sign
+;  [(set (match_operand:HI 0 "register_operand" "=xy,  ?d, ?d,!*xy")
+;	(minus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0")
+;		  (match_operand:HI 2 "general_operand" "mi, mi,!u*A,!umi")))]
+  [(set (match_operand:HI 0 "register_operand" "=dxy,*A,d,*A")
+	(minus:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
+		  (match_operand:HI 2 "general_operand" "im*A*d,im*d*A,u,!u")))]
+  "TARGET_M68S12X"
+  "*
+{
+  /* Adding to an address register or with another/same register
+     is not possible.  This must be replaced.  */
+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))
+     	  return \"#\";
+
+  CC_STATUS_INIT;
+  if (X_REG_P(operands[0]) || Y_REG_P(operands[0]))
+	return \"sub%0\\t%2\";
+  else
+	return \"subd\\t%2\";
+}")
+
 (define_insn "*subhi3_zext"
   [(set (match_operand:HI 0 "hard_reg_operand" "=d,d")
-	(minus:HI (match_operand:HI 1 "hard_reg_operand" "0,0")
+	(minus:HI (match_operand:HI 1 "general_operand" "0,0")
            (zero_extend:HI (match_operand:QI 2 "general_operand" "mi*A,!u"))))]
   ""
   "*
@@ -2743,7 +3108,7 @@
 
 (define_insn "subqi3"
   [(set (match_operand:QI 0 "hard_reg_operand" "=dq,!*x*y")
-        (minus:QI (match_operand:QI 1 "hard_reg_operand" "0,0")
+        (minus:QI (match_operand:QI 1 "general_operand" "0,0")
                   (match_operand:QI 2 "general_operand" "uim*A*d,uim*A*d")))]
   ""
   "*
@@ -2759,6 +3124,16 @@
 ;;
 ;; subtract with carry is used for 32-bit subtract.
 ;;
+
+(define_insn "*sbeBx"
+  [(set (match_operand:HI 0 "register_operand" "=dxy")
+        (minus:HI (minus:HI (reg:HI CC_REGNUM)
+                          (match_operand:HI 1 "register_operand" "%0"))
+                 (match_operand:HI 2 "general_operand" "ium")))]
+  "TARGET_M68S12X"
+  "sbe%0\\t%2")
+
+
 (define_insn "*subcq"
   [(set (match_operand:QI 0 "register_operand" "=q")
         (minus:QI (minus:QI (reg:QI CC_REGNUM)
@@ -2837,6 +3212,32 @@
   return \"emul\\n\\texg\\tx,y\";
 }")
 
+(define_insn "umulhisi3_hc11"
+  [(set (match_operand:SI 0 "register_operand" "=D,D")
+        (mult:SI (zero_extend:SI
+		     (match_operand:HI 1 "register_operand" "%d,Amu"))
+		 (zero_extend:SI
+	             (match_operand:HI 2 "register_operand" "Amu,d"))))
+   (clobber (match_scratch:HI 3 "=y,y"))]
+  "TARGET_M6811"
+  "*
+{
+  CC_STATUS_INIT;
+  if (!H_REG_P (operands[1]))
+    output_asm_insn (\"ldx\\t%1\", operands);
+  if (!H_REG_P (operands[2]))
+    output_asm_insn (\"ldx\\t%2\", operands);
+
+  if (Y_REG_P (operands[1]) || Y_REG_P (operands[2]))
+    output_asm_insn (\"pshy\", operands);
+  else if (X_REG_P (operands[1]) || X_REG_P (operands[2])
+           || !H_REG_P (operands[1]) || !H_REG_P (operands[2]))
+    output_asm_insn (\"pshx\", operands);
+
+  output_asm_insn (\"bsr\\t__mulhi32\", operands);
+  return \"ins\\n\\tins\";
+}")
+
 (define_insn "mulhisi3"
   [(set (match_operand:SI 0 "register_operand" "=D,D")
         (mult:SI (sign_extend:SI
@@ -2896,8 +3297,8 @@
 
 (define_insn "mulqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,*x,*y")
-        (mult:QI (match_operand:QI 1 "nonimmediate_operand" "%dum,0,0")
-		 (match_operand:QI 2 "general_operand" "dium,*xium,*yium")))]
+        (mult:QI (match_operand:QI 1 "general_operand" "%di*um,0,0")
+		 (match_operand:QI 2 "general_operand" "di*um,*xium,*yium")))]
   ""
   "*
 {
@@ -2952,11 +3353,11 @@
   ")
 
 (define_insn "mulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "=d,d")
+  [(set (match_operand:HI 0 "register_operand" "=d,d,d")
         (mult:HI (sign_extend:HI
-			(match_operand:QI 1 "register_operand" "%0,0"))
+			(match_operand:QI 1 "register_operand" "%0,0,0"))
 		 (sign_extend:HI
-                        (match_operand:QI 2 "nonimmediate_operand" "dm,*A"))))]
+                        (match_operand:QI 2 "general_operand" "mi*u,*A,0"))))]
   ""
   "*
 {
@@ -3054,21 +3455,29 @@
 ;;- and instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "anddi3"
+(define_insn_and_split "anddi3"
   [(set (match_operand:DI 0 "reg_or_some_mem_operand" "=m,u")
 	(and:DI (match_operand:DI 1 "reg_or_some_mem_operand" "%imu,imu")
 		(match_operand:DI 2 "general_operand" "imu,imu")))
    (clobber (match_scratch:HI 3 "=d,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (SImode, AND, operands);
+   DONE;")
 
-(define_insn "andsi3"
+(define_insn_and_split "andsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,!u")
 	(and:SI (match_operand:SI 1 "register_operand" "%0,0")
 		(match_operand:SI 2 "general_operand" "Dimu,imu")))
    (clobber (match_scratch:HI 3 "=X,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (HImode, AND, operands);
+   DONE;")
 
 (define_expand "andhi3"
   [(set (match_operand:HI 0 "register_operand" "")
@@ -3078,10 +3487,10 @@
   "")
 
 (define_insn "*andhi3_mem"
-  [(set (match_operand:HI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:HI 0 "memory_operand" "=R,Q")
 	(and:HI (match_dup 0)
 	        (match_operand:HI 1 "immediate_operand" "i,i")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3101,7 +3510,7 @@
   /* When destination is a global variable, generate a .relax instruction
      and load the address in the clobber register.  That load can be
      eliminated by the linker if the address is in page0.  */
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3214,18 +3623,30 @@
   return \"\";
 }")
 
+;slight optimisation to use clra instead of anda#0 if upper byte is zero
 (define_insn "*andhi3_gen"
   [(set (match_operand:HI 0 "register_operand" "=d,d,!*A")
-	(and:HI (match_operand:HI 1 "register_operand" "%0,0,0")
-		(match_operand:HI 2 "general_operand" "mi,!u*A,!um*A")))]
+	(and:HI (match_operand:HI 1 "splitable_operand" "%0,0,0")
+		(match_operand:HI 2 "splitable_operand" "mi,!u*A,!um*Ai")))]
   ""
   "*
 {
   if (A_REG_P (operands[0]) || H_REG_P (operands[2]))
     return \"#\";
 
-  CC_STATUS_INIT;
-  return \"anda\\t%h2\\n\\tandb\\t%b2\";
+  int val = INTVAL (operands[2]);
+
+  if (val & 0xff00)
+    {
+      CC_STATUS_INIT;
+      return \"anda\\t%h2\\n\\tandb\\t%b2\";
+    }
+  else
+    {
+/* In this clause try leaving CC alone so the status from the ANDB is carried through */
+/* In QI bit test cases the clra is redundant but a step in the right direction. */
+    return \"clra\\n\\tandb\\t%b2\";
+    }
 }")
 
 (define_expand "andqi3"
@@ -3236,10 +3657,10 @@
   "")
 
 (define_insn "*andqi3_mem"
-  [(set (match_operand:QI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:QI 0 "memory_operand" "=R,Q")
 	(and:QI (match_dup 0)
 	        (match_operand:QI 1 "const_int_operand" "i,i")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3257,7 +3678,7 @@
   /* When destination is a global variable, generate a .relax instruction
      and load the address in the clobber register.  That load can be
      eliminated by the linker if the address is in page0.  */
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3310,8 +3731,8 @@
 
 (define_insn "*andqi3_gen"
   [(set (match_operand:QI 0 "register_operand" "=d,d,d,?*A,?*A,!*q")
-        (and:QI (match_operand:QI 1 "register_operand" "%0,0,0,0,0,0")
-             (match_operand:QI 2 "general_operand" "mi,!u,?*A,!um,?*A*d,!um*A")))]
+        (and:QI (match_operand:QI 1 "general_operand" "%0,0,0,0,0,0")
+             (match_operand:QI 2 "general_operand" "mi,!*u,?*A,!*um,?*A*d,!*um*A")))]
   ""
   "*
 {
@@ -3330,34 +3751,42 @@
 ;;- Bit set or instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "iordi3"
+(define_insn_and_split "iordi3"
   [(set (match_operand:DI 0 "reg_or_some_mem_operand" "=m,u")
 	(ior:DI (match_operand:DI 1 "reg_or_some_mem_operand" "%imu,imu")
 		(match_operand:DI 2 "general_operand" "imu,imu")))
    (clobber (match_scratch:HI 3 "=d,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (SImode, IOR, operands);
+   DONE;")
 
-(define_insn "iorsi3"
+(define_insn_and_split "iorsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,!u")
 	(ior:SI (match_operand:SI 1 "register_operand" "%0,0")
 		(match_operand:SI 2 "general_operand" "Dimu,imu")))
    (clobber (match_scratch:HI 3 "=X,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (HImode, IOR, operands);
+   DONE;")
 
 (define_expand "iorhi3"
   [(set (match_operand:HI 0 "register_operand" "")
 	(ior:HI (match_operand:HI 1 "register_operand" "")
-		(match_operand:HI 2 "general_operand" "")))]
+		(match_operand:HI 2 "splitable_operand" "")))]
   ""
   "")
 
 (define_insn "*iorhi3_mem"
-  [(set (match_operand:HI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:HI 0 "memory_operand" "=R,Q")
 	(ior:HI (match_dup 0)
 	        (match_operand:HI 1 "const_int_operand" "")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3369,7 +3798,7 @@
       return \"\";
     }
   CC_STATUS_INIT;
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3437,8 +3866,8 @@
 
 (define_insn "*iorhi3_gen"
   [(set (match_operand:HI 0 "register_operand" "=d,d,!*A")
-	(ior:HI (match_operand:HI 1 "register_operand" "%0,0,0")
-		(match_operand:HI 2 "general_operand" "mi,!u*A,!um*A")))]
+	(ior:HI (match_operand:HI 1 "splitable_operand" "%0,0,0")
+		(match_operand:HI 2 "splitable_operand" "mi,!u*A,!um*Ai")))]
   ""
   "*
 {
@@ -3457,10 +3886,10 @@
   "")
 
 (define_insn "*iorqi3_mem"
-  [(set (match_operand:QI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:QI 0 "memory_operand" "=R,Q")
 	(ior:QI (match_dup 0)
 	        (match_operand:QI 1 "const_int_operand" "")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3471,7 +3900,7 @@
       cc_status = cc_prev_status;
       return \"\";
     }
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3520,8 +3949,8 @@
 
 (define_insn "*iorqi3_gen"
   [(set (match_operand:QI 0 "register_operand" "=d,d,d,?*A,?*A,!*q")
-	(ior:QI (match_operand:QI 1 "register_operand" "%0,0,0,0,0,0")
-	     (match_operand:QI 2 "general_operand" "mi,!u,!*A,!um,?*A*d,!um*A")))]
+	(ior:QI (match_operand:QI 1 "general_operand" "%0,0,0,0,0,0")
+	     (match_operand:QI 2 "general_operand" "mi,!*u,!*A,!*um,?*A*d,!*um*A")))]
   ""
   "*
 {
@@ -3541,26 +3970,34 @@
 ;;- xor instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "xordi3"
+(define_insn_and_split "xordi3"
   [(set (match_operand:DI 0 "reg_or_some_mem_operand" "=m,u")
 	(xor:DI (match_operand:DI 1 "reg_or_some_mem_operand" "%imu,imu")
 		(match_operand:DI 2 "general_operand" "imu,imu")))
    (clobber (match_scratch:HI 3 "=d,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (SImode, XOR, operands);
+   DONE;")
 
-(define_insn "xorsi3"
+(define_insn_and_split "xorsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,!u")
 	(xor:SI (match_operand:SI 1 "register_operand" "%0,0")
 		(match_operand:SI 2 "general_operand" "Dimu,imu")))
    (clobber (match_scratch:HI 3 "=X,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (HImode, XOR, operands);
+   DONE;")
 
 (define_insn "xorhi3"
   [(set (match_operand:HI 0 "register_operand" "=d,d,!*A")
-	(xor:HI (match_operand:HI 1 "register_operand" "%0,0,0")
-		(match_operand:HI 2 "general_operand" "im,!u*A,!ium*A")))]
+	(xor:HI (match_operand:HI 1 "splitable_operand" "%0,0,0")
+		(match_operand:HI 2 "splitable_operand" "im,!u*A,!ium*A")))]
   ""
   "*
 {
@@ -3604,8 +4041,8 @@
 
 (define_insn "xorqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,d,d,?*A,?*A,!*q")
-        (xor:QI (match_operand:QI 1 "register_operand" "%0,0,0,0,0,0")
-             (match_operand:QI 2 "general_operand" "im,!u,!*A,!ium,?*A*d,!ium*A")))]
+        (xor:QI (match_operand:QI 1 "general_operand" "%0,0,0,0,0,0")
+             (match_operand:QI 2 "general_operand" "im,!*u,!*A,!i*um,?*A*d,!i*um*A")))]
   ""
   "*
 {
@@ -3641,30 +4078,47 @@
 ;;- Bit set or instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "*logicalsi3_zexthi"
+(define_insn_and_split "*logicalsi3_zexthi"
   [(set (match_operand:SI 0 "register_operand" "=D")
 	(match_operator:SI 3 "m68hc11_logical_operator"
 		[(zero_extend:SI
 		     (match_operand:HI 1 "general_operand" "imudA"))
 		 (match_operand:SI 2 "general_operand" "Dimu")]))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(set (reg:HI D_REGNUM) (match_dup 4))
+   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))
+   (set (reg:HI X_REGNUM) (match_dup 6))]
+  "PUT_MODE (operands[3], HImode);
+   if (X_REG_P (operands[2]))
+     {
+       operands[5] = operands[1];
+       /* Make all the (set (REG:x) (REG:y)) a nop set.  */
+       operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);
+       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+     }
+   else
+     {
+       operands[4] = operands[1];
+       operands[5] = m68hc11_gen_lowpart (HImode, operands[2]);
+       operands[6] = m68hc11_gen_highpart (HImode, operands[2]);
+     }
+   /* For an AND, make sure the high 16-bit part is cleared.  */
+   if (GET_CODE (operands[3]) == AND)
+     {
+       operands[6] = const0_rtx;
+     }
+   ")
 
-(define_insn "*logicalsi3_zextqi"
+(define_insn_and_split "*logicalsi3_zextqi"
   [(set (match_operand:SI 0 "register_operand" "=D,D,D")
 	(match_operator:SI 3 "m68hc11_logical_operator"
 		[(zero_extend:SI
 		     (match_operand:QI 1 "general_operand" "d,*A,imu"))
 		 (match_operand:SI 2 "general_operand" "imu,imu,0")]))]
   ""
-  "#")
-
-(define_split /* logicalsi3_zextqi */
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operator:SI 3 "m68hc11_logical_operator"
-	         [(zero_extend:SI
-		     (match_operand:QI 1 "general_operand" ""))
-		  (match_operand:SI 2 "general_operand" "")]))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:QI A_REGNUM) (match_dup 4))
    (set (reg:QI D_REGNUM) (match_dup 7))
@@ -3695,63 +4149,47 @@
      }
    ")
 
-(define_split /* logicalsi3_zexthi */
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operator:SI 3 "m68hc11_logical_operator"
-	         [(zero_extend:SI
-		     (match_operand:HI 1 "general_operand" ""))
-		  (match_operand:SI 2 "general_operand" "")]))]
-  "reload_completed"
-  [(set (reg:HI D_REGNUM) (match_dup 4))
-   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))
-   (set (reg:HI X_REGNUM) (match_dup 6))]
-  "PUT_MODE (operands[3], HImode);
-   if (X_REG_P (operands[2]))
-     {
-       operands[5] = operands[1];
-       /* Make all the (set (REG:x) (REG:y)) a nop set.  */
-       operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);
-       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);
-     }
-   else
-     {
-       operands[4] = operands[1];
-       operands[5] = m68hc11_gen_lowpart (HImode, operands[2]);
-       operands[6] = m68hc11_gen_highpart (HImode, operands[2]);
-     }
-   /* For an AND, make sure the high 16-bit part is cleared.  */
-   if (GET_CODE (operands[3]) == AND)
-     {
-       operands[6] = const0_rtx;
-     }
-   ")
-
-(define_insn "*logicalhi3_zexthi_ashift8"
+(define_insn_and_split "*logicalhi3_zexthi_ashift8"
   [(set (match_operand:HI 0 "register_operand" "=d")
 	(match_operator:HI 3 "m68hc11_logical_operator"
 		[(zero_extend:HI
-		     (match_operand:QI 1 "general_operand" "imud"))
+		     (match_operand:QI 1 "general_operand" "imud*A"))
 		 (ashift:HI
-		     (match_operand:HI 2 "general_operand" "dimu")
+		     (match_operand:HI 2 "general_operand" "imud*A")
 		     (const_int 8))]))]
   ""
-  "#")
+  "#"
+  "z_replacement_completed == 2"
+  [(set (reg:QI A_REGNUM) (match_dup 4))
+   (set (reg:QI B_REGNUM) (match_dup 5))]
+  "
+   if (GET_CODE (operands[3]) == AND)
+     {
+       emit_insn (gen_movhi (operands[0], const0_rtx));
+       DONE;
+     }
+   else
+     {
+       operands[5] = operands[1];
+       if (D_REG_P (operands[2]))
+         {
+           operands[4] = gen_rtx (REG, QImode, HARD_B_REGNUM);
+         }
+       else
+         {
+           operands[4] = m68hc11_gen_lowpart (QImode, operands[2]);
+         }
+     }
+  ")
 
-(define_insn "*logicalhi3_zexthi"
+(define_insn_and_split "*logicalhi3_zexthi"
   [(set (match_operand:HI 0 "register_operand" "=d,d")
 	(match_operator:HI 3 "m68hc11_logical_operator"
 		[(zero_extend:HI
 		     (match_operand:QI 1 "general_operand" "imd*A,?u"))
 		 (match_operand:HI 2 "general_operand" "dim,?dimu")]))]
   ""
-  "#")
-
-(define_split /* logicalhi3_zexthi */
-  [(set (match_operand:HI 0 "register_operand" "")
-	(match_operator:HI 3 "m68hc11_logical_operator"
-		[(zero_extend:HI
-		     (match_operand:QI 1 "general_operand" ""))
-		 (match_operand:HI 2 "general_operand" "")]))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:QI B_REGNUM) (match_dup 6))
    (set (reg:QI A_REGNUM) (match_dup 4))
@@ -3780,54 +4218,16 @@
      }
   ")
 
-(define_split /* logicalhi3_zexthi_ashift8 */
-  [(set (match_operand:HI 0 "register_operand" "")
-	(match_operator:HI 3 "m68hc11_logical_operator"
-		[(zero_extend:HI
-		     (match_operand:QI 1 "general_operand" ""))
-		 (ashift:HI
-		     (match_operand:HI 2 "general_operand" "")
-		     (const_int 8))]))]
-  "z_replacement_completed == 2"
-  [(set (reg:QI A_REGNUM) (match_dup 4))
-   (set (reg:QI B_REGNUM) (match_dup 5))]
-  "
-   if (GET_CODE (operands[3]) == AND)
-     {
-       emit_insn (gen_movhi (operands[0], const0_rtx));
-       DONE;
-     }
-   else
-     {
-       operands[5] = operands[1];
-       if (D_REG_P (operands[2]))
-         {
-           operands[4] = gen_rtx (REG, QImode, HARD_B_REGNUM);
-         }
-       else
-         {
-           operands[4] = m68hc11_gen_lowpart (QImode, operands[2]);
-         }
-     }
-  ")
 
-(define_insn "*logicalsi3_silshr16"
-  [(set (match_operand:SI 0 "register_operand" "=D,D,D")
+(define_insn_and_split "*logicalsi3_silshr16"
+  [(set (match_operand:SI 0 "register_operand" "=D,D,D,?D")
           (match_operator:SI 3 "m68hc11_logical_operator"
 	      [(lshiftrt:SI 
-		   (match_operand:SI 1 "general_operand" "uim,uim,?D")
+		   (match_operand:SI 1 "general_operand" "uim,uim,0,0")
 		   (const_int 16))
-		(match_operand:SI 2 "general_operand" "uim,0,0")]))]
+		(match_operand:SI 2 "general_operand" "uim,0,uim,0")]))]
   ""
-  "#")
-
-(define_split /* logicalsi3_silshr16 */
-  [(set (match_operand:SI 0 "register_operand" "")
-          (match_operator:SI 3 "m68hc11_logical_operator"
-		[(lshiftrt:SI 
-			(match_operand:SI 1 "general_operand" "")
-			(const_int 16))
-		 (match_operand:SI 2 "general_operand" "")]))]
+  "#"
   "reload_completed"
   [(set (reg:HI D_REGNUM) (match_dup 4))
    (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))
@@ -3852,7 +4252,7 @@
      }
 ")
 
-(define_insn "*logicalsi3_silshl16"
+(define_insn_and_split "*logicalsi3_silshl16"
   [(set (match_operand:SI 0 "register_operand" "=D,D")
           (match_operator:SI 3 "m68hc11_logical_operator"
 	      [(ashift:SI 
@@ -3860,15 +4260,7 @@
 		   (const_int 16))
 		(match_operand:SI 2 "general_operand" "0,0")]))]
   ""
-  "#")
-
-(define_split /* logicalsi3_silshl16 */
-  [(set (match_operand:SI 0 "register_operand" "")
-          (match_operator:SI 3 "m68hc11_logical_operator"
-		[(ashift:SI 
-			(match_operand:SI 1 "general_operand" "")
-			(const_int 16))
-		 (match_operand:SI 2 "general_operand" "")]))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:HI X_REGNUM) (match_op_dup 3 [(reg:HI X_REGNUM) (match_dup 4)]))
    (set (reg:HI D_REGNUM) (match_dup 5))]
@@ -3881,48 +4273,45 @@
      operands[5] = gen_rtx (REG, HImode, HARD_D_REGNUM);
    ")
 
-
-;;--------------------------------------------------------------------
-;;- 64/32-bit Logical Operations.  Patterns are defined so that GCC
-;; can optimize correctly.  These insns are split by the `final'
-;; pass (# pattern).  They are split to fall in the corresponding
-;; 16-bit logical patterns.
-;;--------------------------------------------------------------------
-
-;; Split 64-bit logical operations: anddi3, iordi3, xordi3
-(define_split
-  [(set (match_operand:DI 0 "reg_or_some_mem_operand" "")
-	(match_operator:DI 4 "m68hc11_logical_operator"
-	     [(match_operand:DI 1 "reg_or_some_mem_operand" "")
-	      (match_operand:DI 2 "general_operand" "")]))
-   (clobber (match_scratch:HI 3 ""))]
+(define_insn_and_split "*logicalsi3_silshl16_zext"
+  [(set (match_operand:SI 0 "register_operand" "=D,D,D")
+          (match_operator:SI 3 "m68hc11_logical_operator"
+	      [(ashift:SI
+	          (zero_extend:SI
+		     (match_operand:HI 1 "general_operand" "uim,udA,!dA"))
+		  (const_int 16))
+	    (zero_extend:SI (match_operand:HI 2 "general_operand" "uidA,um,!dA"))]))]
+  ""
+  "#"
+  ;; Must split before z register replacement
   "reload_completed"
-  [(const_int 0)]
-  "m68hc11_split_logical (SImode, GET_CODE (operands[4]), operands);
-   DONE;")
-
-;; Split 32-bit logical operations: andsi3, iorsi3, xorsi3
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operator:SI 3 "m68hc11_logical_operator"
-	     [(match_operand:SI 1 "register_operand" "")
-	      (match_operand:SI 2 "general_operand" "")]))]
-  "0 && reload_completed"
-  [(const_int 0)]
-  "m68hc11_split_logical (HImode, GET_CODE (operands[3]), operands);
-   DONE;")
+  [(set (match_dup 4) (match_dup 5))
+   (set (match_dup 6) (match_dup 7))]
+  "
+    /* set (X_REGNUM) (d), set (D_REGNUM) (1) */
+   if (GET_CODE (operands[1]) == HARD_D_REGNUM
+       && GET_CODE (operands[3]) != AND)
+     {
+       /* This particular case is too early to be split before
+          Z register replacement because the cse-reg pass we do
+	  does not recognize the 'swap_areg'.  It is ok to handle
+	  this case after.  */
+       if (z_replacement_completed != 2)
+         {
+	   FAIL;
+	 }
+       emit_move_insn (gen_rtx (REG, HImode, HARD_X_REGNUM), operands[2]);
+       emit_insn (gen_swap_areg (gen_rtx (REG, HImode, HARD_D_REGNUM),
+			         gen_rtx (REG, HImode, HARD_X_REGNUM)));
+     }
+   operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);
+   operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+   operands[5] = operands[2];
+   operands[7] = operands[1];
 
-;; Split 32-bit logical operations: andsi3, iorsi3, xorsi3
-(define_split
-  [(set (match_operand:SI 0 "reg_or_some_mem_operand" "")
-	(match_operator:SI 4 "m68hc11_logical_operator"
-	     [(match_operand:SI 1 "reg_or_some_mem_operand" "")
-	      (match_operand:SI 2 "general_operand" "")]))
-   (clobber (match_scratch:HI 3 ""))]
-  "reload_completed"
-  [(const_int 0)]
-  "m68hc11_split_logical (HImode, GET_CODE (operands[4]), operands);
-   DONE;")
+   if (GET_CODE (operands[3]) == AND)
+     operands[5] = operands[7] = const0_rtx;
+   ")
 
 ;;--------------------------------------------------------------------
 ;; 16-bit Arithmetic and logical operations on X and Y:
@@ -4305,8 +4694,16 @@
   ops[0] = gen_label_rtx ();
 
   /* 32-bit complement and add 1.  */
+  if (TARGET_M68S12X)
+    {
+      output_asm_insn (\"comx\\n\\txgdx\\n\\tcomx\", operands);
+    }
+  else
+    {
   output_asm_insn (\"comb\\n\\tcoma\\n\\txgdx\", operands);
-  output_asm_insn (\"comb\\n\\tcoma\\n\\tinx\\n\\txgdx\", operands);
+      output_asm_insn (\"comb\\n\\tcoma\\n\", operands);
+    }
+  output_asm_insn (\"inx\\n\\txgdx\", operands);
   output_asm_insn (\"bne\\t%l0\", ops);
   output_asm_insn (\"inx\", operands);
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (ops[0]));
@@ -4317,14 +4714,33 @@
   [(set (match_operand:HI 0 "register_operand" "=d,d,x*y")
 	(neg:HI (match_operand:HI 1 "general_operand" "0,!duim,0")))]
   ""
-  "@
-   coma\\n\\tcomb\\n\\taddd\\t#1
-   clra\\n\\tclrb\\n\\tsubd\\t%1
-   xgd%0\\n\\tcoma\\n\\tcomb\\n\\txgd%0\\n\\tin%0")
+  "*
+    {
+    if (which_alternative == 0)
+      {
+        return \"coma\\n\\tcomb\\n\\taddd\\t#1\";
+      }
+    else if (which_alternative == 1)
+      {
+        return \"clra\\n\\tclrb\\n\\tsubd\\t%1\";
+      }
+    else
+      {
+        if (TARGET_M68S12X)
+          {
+            return \"com%0\\n\\tin%0\";
+          }
+        else
+          {
+            return \"xgd%0\\n\\tcoma\\n\\tcomb\\n\\txgd%0\\n\\tin%0\";
+          }
+      }
+    }
+  ")
 
 (define_insn "negqi2"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m,!u,!*A")
-	(neg:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")))]
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m,!u,!*A")
+	(neg:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0")))]
   ""
   "@
    negb
@@ -4421,19 +4837,13 @@
     }
 }")
 
-(define_insn "*ashldi3_const32"
+(define_insn_and_split "*ashldi3_const32"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=<,m,u")
 	(ashift:DI (match_operand:DI 1 "general_operand" "umi,umi,umi")
 		   (const_int 32)))
    (clobber (match_scratch:HI 2 "=&A,d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(ashift:DI (match_operand:DI 1 "general_operand" "")
-		   (const_int 32)))
-   (clobber (match_scratch:HI 2 ""))]
+   "#"
    "reload_completed"
    [(const_int 0)]
    "/* Move the lowpart in the highpart first in case the shift
@@ -4442,6 +4852,13 @@
       {
          m68hc11_split_move (m68hc11_gen_lowpart (SImode, operands[0]),
 			     const0_rtx, operands[2]);
+
+         /* Adjust first operand if it uses SP so that we take into
+            account the above push.  Can occur only for 68HC12.  */
+         if (reg_mentioned_p (gen_rtx (REG, HImode, HARD_SP_REGNUM),
+	                      operands[1]))
+           operands[1] = adjust_address (operands[1],
+	                                 GET_MODE (operands[0]), 4);
       }
     m68hc11_split_move (m68hc11_gen_highpart (SImode, operands[0]),
 		        m68hc11_gen_lowpart (SImode, operands[1]),
@@ -4453,19 +4870,13 @@
       }
     DONE;")
 
-(define_insn "*ashldi3_const1"
+(define_insn_and_split "*ashldi3_const1"
   [(set (match_operand:DI 0 "non_push_operand" "=m,m,u")
 	(ashift:DI (match_operand:DI 1 "general_operand" "mi,u,umi")
 		   (const_int 1)))
    (clobber (match_scratch:HI 2 "=d,d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "non_push_operand" "")
-	(ashift:DI (match_operand:DI 1 "general_operand" "")
-		   (const_int 1)))
-   (clobber (match_scratch:HI 2 ""))]
+   "#"
    "z_replacement_completed == 2"
    [(set (match_dup 2) (match_dup 3))
     (set (match_dup 2) (ashift:HI (match_dup 2) (const_int 1)))
@@ -4505,10 +4916,10 @@
     operands[8] = m68hc11_gen_lowpart (HImode, operands[8]);")
 
 (define_insn "addsi_silshr16"
-  [(set (match_operand:SI 0 "register_operand" "=D,D")
-          (plus:SI (lshiftrt:SI (match_operand:SI 1 "general_operand" "!*uim,0")
+  [(set (match_operand:SI 0 "register_operand" "=D,D,!D")
+          (plus:SI (lshiftrt:SI (match_operand:SI 1 "general_operand" "!*uim,0,0")
 				(const_int 16))
-		   (match_operand:SI 2 "general_operand" "0,m!*u")))]
+		   (match_operand:SI 2 "general_operand" "0,m!*u,0")))]
   ""
   "#")
 
@@ -4530,14 +4941,24 @@
 				(const_int 16))
 		   (match_operand:SI 2 "general_operand" "")))]
   "z_replacement_completed == 2 && X_REG_P (operands[1])"
-  [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))
+  [(set (reg:HI D_REGNUM) (match_dup 5))
    (set (reg:HI X_REGNUM) (match_dup 3))
    (set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 4)))
    (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM)
 					    (const_int 0))
 				   (reg:HI CC_REGNUM)))]
   "operands[3] = m68hc11_gen_highpart (HImode, operands[2]);
-   operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);")
+   if (X_REG_P (operands[2]))
+     {
+       operands[4] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+       operands[5] = gen_rtx (REG, HImode, HARD_D_REGNUM);
+     }
+   else
+     {
+       operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);
+       operands[5] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+     }
+")
 
 (define_insn "addsi_ashift16"
   [(set (match_operand:SI 0 "register_operand" "=D")
@@ -4563,24 +4984,27 @@
   operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);
 }")
 
-(define_insn "addsi_andshr16"
+(define_insn_and_split "addsi_andshr16"
   [(set (match_operand:SI 0 "register_operand" "=D")
           (plus:SI (and:SI (match_operand:SI 1 "general_operand" "%uim")
 			   (const_int 65535))
 		   (match_operand:SI 2 "general_operand" "0")))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-          (plus:SI (and:SI (match_operand:SI 1 "general_operand" "")
-			   (const_int 65535))
-		   (match_operand:SI 2 "general_operand" "")))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))
    (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM) (const_int 0)) (reg:HI CC_REGNUM)))]
   "operands[3] = m68hc11_gen_lowpart (HImode, operands[1]);")
 
+(define_insn "subhi_ashlhi8"
+  [(set (match_operand:HI 0 "register_operand" "=d")
+          (minus:HI (match_operand:HI 1 "register_operand" "0")
+                    (mult:HI (match_operand:HI 2 "register_operand" "0")
+			     (const_int 256))))]
+  "0"
+  "@
+   sba")
+
 ;;
 ;; 32-bit shifts are made by a small library routine that uses
 ;; a specific passing convention for parameters (for efficiency reasons).
@@ -4622,38 +5046,38 @@
    ""
    "#")
 
-(define_insn "*ashlsi3_const16_zexthi"
+(define_insn_and_split "*ashlsi3_const16_zexthi"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=D")
 	(ashift:SI (zero_extend:HI 
 			(match_operand:HI 1 "general_operand" "duim*A"))
 	           (const_int 16)))
    (clobber (match_scratch:HI 2 "=X"))]
    ""
-   "#")
-
-(define_split /* "*ashlsi3_const16_zexthi"*/
-  [(set (match_operand:SI 0 "nonimmediate_operand" "")
-	(ashift:SI (zero_extend:HI 
-			(match_operand:HI 1 "general_operand" ""))
-	           (const_int 16)))
-   (clobber (match_scratch:HI 2 "=X"))]
+   "#"
    "reload_completed"
    [(set (reg:HI X_REGNUM) (match_dup 1))
     (set (reg:HI D_REGNUM) (const_int 0))]
    "")
 
 (define_insn "*ashlsi3_const1"
-  [(set (match_operand:SI 0 "non_push_operand" "=D,D,m,!*u,?*um")
-	(ashift:SI (match_operand:SI 1 "nonimmediate_operand" "0,*um,0,0,*um")
+  [(set (match_operand:SI 0 "non_push_operand" "=D,D,D,m,*u,*u")
+	(ashift:SI (match_operand:SI 1 "nonimmediate_operand" "0,m,*u,m,*u,m")
 	           (const_int 1)))
-   (clobber (match_scratch:HI 2 "=X,X,&d,&d,&d"))]
+   (clobber (match_scratch:HI 2 "=X,X,X,&d,&d,&d"))]
    ""
    "*
 {
   CC_STATUS_INIT;
   if (X_REG_P (operands[1]))
     {
-      return \"lsld\\n\\txgdx\\n\\trolb\\n\\trola\\n\\txgdx\";
+      if (TARGET_M68S12X)
+        {
+          return \"lsld\\n\\trolx\";
+        }
+      else
+        {
+          return \"lsld\\n\\txgdx\\n\\trolb\\n\\trola\\n\\txgdx\";
+        }
     }
   else
     {
@@ -4669,30 +5093,33 @@
 	  ops[0] = m68hc11_gen_lowpart (HImode, operands[0]);
 	  m68hc11_gen_movhi (insn, ops);
 	  ops[0] = ops[1];
-          ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
-          m68hc11_gen_movhi (insn, ops);
-	}
-      else
-	{
-	  /* Load the high part in X in case the source operand
-	     uses X as a memory pointer.  */
-	  ops[0] = gen_rtx (REG, HImode, HARD_X_REGNUM);
-          ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
-          m68hc11_gen_movhi (insn, ops);
-          output_asm_insn (\"xgdx\", ops);
-	}
+      ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
+      m68hc11_gen_movhi (insn, ops);
       output_asm_insn (\"rolb\", ops);
       output_asm_insn (\"rola\", ops);
-      if (!X_REG_P (operands[0]))
-	{
 	  ops[1] = ops[0];
 	  ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
 	  m68hc11_gen_movhi (insn, ops);
+    }
+    else
+	{
+	  /* Load the high part in X in case the source operand
+	     uses X as a memory pointer.  */
+	  ops[0] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+    ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
+    m68hc11_gen_movhi (insn, ops);
+    if (TARGET_M68S12X)
+      {
+        output_asm_insn (\"rolx\", ops);
+      }
+    else
+      {
+        output_asm_insn (\"xgdx\", ops);
+        output_asm_insn (\"rolb\", ops);
+        output_asm_insn (\"rola\", ops);
+        output_asm_insn (\"xgdx\", ops);
+      }
 	}
-      else
-        {
-          output_asm_insn (\"xgdx\", ops);
-        }
       return \"\";
     }
 }")
@@ -4702,7 +5129,7 @@
 	(ashift:SI (match_dup 0)
 	           (match_operand:HI 1 "const_int_operand" "")))
    (clobber (match_scratch:HI 2 "=y"))]
-   ""
+   "TARGET_M6811 /* See *ashlsi3 note.  */"
    "*
 {
   CC_STATUS_INIT;
@@ -4712,7 +5139,7 @@
 (define_insn "*ashlsi3"
   [(set (match_operand:SI 0 "register_operand" "+D,D")
 	(ashift:SI (match_dup 0)
-	           (match_operand:HI 1 "general_operand" "y,m")))
+	           (match_operand:HI 1 "general_operand" "y,mi")))
    (clobber (match_scratch:HI 2 "=1,X"))]
    ""
    "*
@@ -4725,7 +5152,12 @@
      is not enough register in class A_REGS.
 
      Assuming that 'operands[1]' does not refer to the stack (which 
-     is true for 68hc11 only, we save temporary the value of Y.  */
+     is true for 68hc11 only, we save temporary the value of Y.
+
+     For 68HC12 we must also accept a constant because Z register is
+     disabled when compiling with -fomit-frame-pointer.  We can come up
+     with a reload problem and the *lshrsi3_const pattern was disabled
+     for that reason.  */
   if (!Y_REG_P (operands[2]))
     {
       rtx ops[1];
@@ -4780,9 +5212,16 @@
     {
       return \"asld\";
     }
-  
-  output_asm_insn (\"asl\\t%b0\", operands);
-  output_asm_insn (\"rol\\t%h0\", operands);
+  
+  if (TARGET_M68S12X)
+    {
+    output_asm_insn (\"aslw\\t%0\", operands);
+    }
+  else
+    {
+    output_asm_insn (\"asl\\t%b0\", operands);
+    output_asm_insn (\"rol\\t%h0\", operands);
+  }
   CC_STATUS_INIT;
   return \"\";
 }")
@@ -4861,8 +5300,8 @@
    "")
 
 (define_insn "*ashlqi3_const1"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m,!u,!*q,!*A")
-	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m,!u,!*q,!*A")
+	(ashift:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0,0")
 	           (const_int 1)))]
   ""
   "@
@@ -5112,7 +5551,7 @@
 	(ashiftrt:SI (match_dup 0)
 	             (match_operand:HI 1 "const_int_operand" "")))
    (clobber (match_scratch:HI 2 "=y"))]
-   ""
+   "TARGET_M6811 /* See *ashrsi3 note.  */"
    "*
 {
   CC_STATUS_INIT;
@@ -5122,7 +5561,7 @@
 (define_insn "*ashrsi3"
   [(set (match_operand:SI 0 "register_operand" "+D,D")
 	(ashiftrt:SI (match_dup 0)
-	             (match_operand:HI 1 "general_operand" "y,m")))
+	             (match_operand:HI 1 "general_operand" "y,mi")))
    (clobber (match_scratch:HI 2 "=1,X"))]
    ""
    "*
@@ -5134,7 +5573,12 @@
      is not enough register in class A_REGS.
 
      Assuming that 'operands[1]' does not refer to the stack (which 
-     is true for 68hc11 only, we save temporary the value of Y.  */
+     is true for 68hc11 only, we save temporary the value of Y.
+
+     For 68HC12 we must also accept a constant because Z register is
+     disabled when compiling with -fomit-frame-pointer.  We can come up
+     with a reload problem and the *lshrsi3_const pattern was disabled
+     for that reason.  */
   if (!Y_REG_P (operands[2]))
     {
       rtx ops[1];
@@ -5162,8 +5606,8 @@
    "")
 
 (define_insn "*ashrqi3_const1"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m,!u,!*q,!*A")
-	(ashiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m,!u,!*q,!*A")
+	(ashiftrt:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0,0")
 		     (const_int 1)))]
   ""
   "@
@@ -5240,19 +5684,13 @@
     }
 }")
 
-(define_insn "*lshrdi3_const32"
+(define_insn_and_split "*lshrdi3_const32"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=<,m,u")
 	(lshiftrt:DI (match_operand:DI 1 "general_operand" "umi,umi,umi")
 		     (const_int 32)))
    (clobber (match_scratch:HI 2 "=&A,d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(lshiftrt:DI (match_operand:DI 1 "general_operand" "")
-		     (const_int 32)))
-   (clobber (match_scratch:HI 2 "=&A,d"))]
+   "#"
    "reload_completed"
    [(const_int 0)]
    "m68hc11_split_move (m68hc11_gen_lowpart (SImode, operands[0]),
@@ -5322,19 +5760,13 @@
     operands[7] = m68hc11_gen_highpart (HImode, operands[6]);
     operands[6] = m68hc11_gen_lowpart (HImode, operands[6]);")
 
-(define_insn "*lshrdi_const1"
+(define_insn_and_split "*lshrdi_const1"
   [(set (match_operand:DI 0 "non_push_operand" "=m,u")
 	(lshiftrt:DI (match_operand:DI 1 "general_operand" "umi,umi")
 		     (const_int 1)))
    (clobber (match_scratch:HI 2 "=d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "non_push_operand" "")
-	(lshiftrt:DI (match_operand:DI 1 "general_operand" "")
-		     (const_int 1)))
-   (clobber (match_scratch:HI 2 ""))]
+   "#"
    "z_replacement_completed == 2"
    [(set (match_dup 2) (match_dup 3))
     (set (match_dup 2) (lshiftrt:HI (match_dup 2) (const_int 1)))
@@ -5407,17 +5839,24 @@
     #")
 
 (define_insn "*lshrsi3_const1"
-  [(set (match_operand:SI 0 "non_push_operand" "=D,m,*u")
-	(lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "D*um,*um,*um")
+  [(set (match_operand:SI 0 "non_push_operand" "=D,D,D,m,*u,*u")
+	(lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "0,m,*u,m,*u,m")
 	             (const_int 1)))
-   (clobber (match_scratch:HI 2 "=X,&d,&d"))]
+   (clobber (match_scratch:HI 2 "=X,X,X,&d,&d,&d"))]
    ""
    "*
 {
   CC_STATUS_INIT;
   if (X_REG_P (operands[1]))
     {
+      if (TARGET_M68S12X)
+        {
+          return \"lsrx\\n\\trora\\n\\trorb\";
+        }
+      else
+        {
       return \"xgdx\\n\\tlsrd\\n\\txgdx\\n\\trora\\n\\trorb\";
+        }
     }
   else
     {
@@ -5461,7 +5900,7 @@
 	(lshiftrt:SI (match_dup 0)
 	             (match_operand:HI 1 "const_int_operand" "")))
    (clobber (match_scratch:HI 2 "=y"))]
-   ""
+   "TARGET_M6811 /* See *lshrsi3 note.  */"
    "*
 {
   CC_STATUS_INIT;
@@ -5471,7 +5910,7 @@
 (define_insn "*lshrsi3"
   [(set (match_operand:SI 0 "register_operand" "+D,D")
 	(lshiftrt:SI (match_dup 0)
-	             (match_operand:HI 1 "general_operand" "y,m")))
+	             (match_operand:HI 1 "general_operand" "y,mi")))
    (clobber (match_scratch:HI 2 "=1,X"))]
    ""
    "*
@@ -5483,7 +5922,12 @@
      is not enough register in class A_REGS.
 
      Assuming that 'operands[1]' does not refer to the stack (which 
-     is true for 68hc11 only, we save temporary the value of Y.  */
+     is true for 68hc11 only, we save temporary the value of Y.
+
+     For 68HC12 we must also accept a constant because Z register is
+     disabled when compiling with -fomit-frame-pointer.  We can come up
+     with a reload problem and the *lshrsi3_const pattern was disabled
+     for that reason.  */
   if (!Y_REG_P (operands[2]))
     {
       rtx ops[1];
@@ -5544,8 +5988,8 @@
 }")
 
 (define_insn "lshrhi3_const"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,d,!*A,!*A")
-	(lshiftrt:HI (match_operand:HI 1 "general_operand" "dm*A,!u,dm,!u")
+  [(set (match_operand:HI 0 "nonimmediate_noinc_operand" "=d,d,!*A,!*A")
+	(lshiftrt:HI (match_operand:HI 1 "nonimmediate_noinc_operand" "dm*A,!u,dm,!u")
 		     (match_operand:HI 2 "const_int_operand" "i,i,i,i")))]
   ""
   "*
@@ -5649,8 +6093,8 @@
    "")
 
 (define_insn "*lshrqi3_const1"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,d,!u,!*q,!*A")
-	(lshiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=m,d,!u,!*q,!*A")
+	(lshiftrt:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0,0")
 		     (const_int 1)))]
   ""
   "@
@@ -5937,6 +6381,98 @@
   "")
 
 ;;--------------------------------------------------------------------
+;;-  Bit test and branch
+;;--------------------------------------------------------------------
+;; Logical and, test if zero and branch to use "brset/brclr" instruction
+;;
+(define_insn "brclr"
+  [(set (pc)
+	(if_then_else
+	  (eq (and:QI (match_operand:QI 0 "memory_operand" "R,Q")
+		      (match_operand:QI 1 "const_int_operand" ""))
+              (const_int 0))
+	 (label_ref (match_operand 2 "" ""))
+	 (pc)))
+   (clobber (match_scratch:HI 3 "=X,xy"))]
+  "0"
+  "*
+{
+  cc_status = cc_prev_status;
+  if (which_alternative == 0 || TARGET_M6812)
+    {
+      return \"brclr\\t%0,%1,%l2\";
+    }
+  else
+    {
+      rtx ops[3];
+
+      ops[0] = operands[3];
+      ops[1] = XEXP (operands[0], 0);
+      ops[2] = gen_label_rtx ();
+      output_asm_insn (\".relax\\t%l2\", ops);
+      m68hc11_gen_movhi (insn, ops);
+      output_asm_insn (\"brclr\\t0,%3,%1,%l2\", operands);
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+				 CODE_LABEL_NUMBER (ops[2]));
+      return \"\";
+    }
+}")
+
+(define_insn "brset"
+  [(set (pc)
+	(if_then_else
+	  (eq (and:QI (not:QI (match_operand:QI 0 "memory_operand" "R,Q"))
+		      (match_operand:QI 1 "const_int_operand" ""))
+              (const_int 0))
+	 (label_ref (match_operand 2 "" ""))
+	 (pc)))
+   (clobber (match_scratch:HI 3 "=X,xy"))]
+  "0"
+  "*
+{
+  cc_status = cc_prev_status;
+  if (which_alternative == 0 || TARGET_M6812)
+    {
+      return \"brset\\t%0,%1,%l2\";
+    }
+  else
+    {
+      rtx ops[3];
+
+      ops[0] = operands[3];
+      ops[1] = XEXP (operands[0], 0);
+      ops[2] = gen_label_rtx ();
+      output_asm_insn (\".relax\\t%l2\", ops);
+      m68hc11_gen_movhi (insn, ops);
+      output_asm_insn (\"brset\\t0,%3,%1,%l2\", operands);
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+				 CODE_LABEL_NUMBER (ops[2]));
+      return \"\";
+    }
+}")
+
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+        (match_operand:QI 1 "memory_operand" "m"))
+   (set (cc0) (and:HI (match_operand:HI 2 "hard_reg_operand" "")
+	              (match_operand:HI 3 "const_int_operand" "")))
+   (set (pc)
+        (if_then_else (eq (cc0) (const_int 0))
+		      (label_ref (match_operand 4 "" ""))
+		      (pc)))]
+  "0 && REGNO (operands[0]) == REGNO (operands[2])
+   && peep2_reg_dead_p (2, operands[0])"
+  [(parallel [
+      (set (pc)
+        (if_then_else
+           (eq (and:QI (match_dup 1) (match_dup 3))
+               (const_int 0))
+	   (label_ref (match_dup 4))
+           (pc)))
+      (clobber (match_dup 5))])]
+  "operands[5] = gen_rtx_SCRATCH (HImode);")
+
+;;--------------------------------------------------------------------
 ;;-  68HC12 Decrement/Increment and branch
 ;;--------------------------------------------------------------------
 ;; These patterns are used by loop optimization as well as peephole2
@@ -5976,17 +6512,24 @@
     {
       FAIL;
     }
+
+  /* Note that for xxx_dbcc_dec_yy the gen_rtx_NE is only used to pass
+     the operator and its operands are not relevant.  */
   if (GET_MODE (operands[0]) == HImode)
     {
       emit_jump_insn (gen_m68hc12_dbcc_dec_hi (operands[0],
-					       gen_rtx (NE, HImode),
+					       gen_rtx (NE, HImode,
+						        operands[0],
+							operands[1]),
 					       operands[4]));
       DONE;
     }
   if (GET_MODE (operands[0]) == QImode)
     {
       emit_jump_insn (gen_m68hc12_dbcc_dec_qi (operands[0],
-					       gen_rtx (NE, QImode),
+					       gen_rtx (NE, QImode,
+						        operands[0],
+							operands[1]),
 					       operands[4]));
       DONE;
     }
@@ -6928,18 +7471,81 @@
 ;;
 ;; Replace "leas 2,sp" with a "pulx" or a "puly".
 ;; On 68HC12, this is one cycle slower but one byte smaller.
-;; pr target/6899: This peephole is not valid because a register CSE
-;; pass removes the pulx/puly.
+;; pr target/6899: This peephole was not valid because a register CSE
+;; pass removes the pulx/puly.  The 'use' clause ensure that the pulx is
+;; not removed.
 ;;
 (define_peephole2
   [(set (reg:HI SP_REGNUM) (plus:HI (reg:HI SP_REGNUM) (const_int 2)))
    (match_scratch:HI 0 "xy")]
-  "0 && TARGET_M6812 && optimize_size"
-  [(set (match_dup 0) (match_dup 1))]
+  "TARGET_M6812 && optimize_size"
+  [(set (match_dup 0) (match_dup 1))
+   (use (match_dup 0))]
   "operands[1] = gen_rtx (MEM, HImode,
 			  gen_rtx (POST_INC, HImode,
 				   gen_rtx_REG (HImode, HARD_SP_REGNUM)));")
 
+;; Replace: "pshx; tfr d,x; stx 0,sp" into "pshd; tfr d,x"
+;;
+;; PR 14542: emit a use to pretend we need the value of initial register.
+;; Otherwise verify_local_live_at_start will abort due to a live change
+;; of that register.
+;;
+(define_peephole2
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_operand:HI 0 "hard_reg_operand" ""))
+   (set (match_dup 0)
+        (match_operand:HI 1 "hard_reg_operand" ""))
+   (set (mem:HI (reg:HI SP_REGNUM))
+        (match_dup 0))]
+  "TARGET_M6812"
+  [(use (match_dup 0))
+   (set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_dup 1))
+   (set (match_dup 0) (match_dup 1))]
+  "")
+
+;;
+;; Change: "ldd 0,sp; pulx" into  "puld"
+;; This sequence usually appears at end a functions.
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+        (mem:HI (reg:HI SP_REGNUM)))
+   (use (match_dup 0))
+   (set (match_operand:HI 1 "hard_reg_operand" "")
+        (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]
+  "peep2_reg_dead_p (2, operands[1])"
+  [(set (match_dup 0) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))
+   (use (match_dup 0))]
+  "")
+
+;; Replace: "pshx; clr 0,sp; clr 1,sp" by "clr 1,-sp; clr 1,-sp"
+;; Appears to allocate local variables.
+(define_peephole2
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_operand:HI 0 "hard_reg_operand" ""))
+   (set (mem:QI (plus:HI (reg:HI SP_REGNUM) (const_int 1)))
+        (const_int 0))
+   (set (mem:QI (reg:HI SP_REGNUM))
+        (const_int 0))]
+  "TARGET_M6812"
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (const_int 0))]
+  "")
+
+;; Likewise for HI mode
+(define_peephole2
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_operand:HI 0 "hard_reg_operand" ""))
+   (set (mem:HI (reg:HI SP_REGNUM))
+        (const_int 0))]
+  "TARGET_M6812"
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (const_int 0))]
+  "")
+;;--------------------------------------------------------------------
+;;- 
+;;--------------------------------------------------------------------
 ;;
 ;; Optimize memory<->memory moves when the value is also loaded in
 ;; a register.
@@ -6989,6 +7595,32 @@
    (set (match_dup 0) (match_dup 2))]
   "")
 
+;;--------------------------------------------------------------------
+;;- 
+;;--------------------------------------------------------------------
+;; SCz 2005-05-08: this peephole2 is not finished.  I'm not sure it is
+;; valid in all cases.  Disabled but kept for documentation and futur fix.
+;; (optimize 8-bit move to/from the X or Y registers; the issue with
+;; the first (set) is that since operand 0 is either X or Y, we have to
+;; use the scratch _.tmp memory location; the peephole uses a stack location
+;; instead to save D and use D for the load)
+;;
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+	(match_operand:QI 1 "memory_operand" ""))
+   (set (match_operand:QI 2 "memory_operand" "")
+        (match_dup 0))]
+  "0 && A_REG_P (operands[0]) && peep2_reg_dead_p (2, operands[0])
+   && !reg_mentioned_p (gen_rtx (REG, HImode, HARD_D_REGNUM), operands[1])
+   && !reg_mentioned_p (gen_rtx (REG, HImode, HARD_D_REGNUM), operands[1])
+   && !reg_mentioned_p (gen_rtx (REG, HImode, REGNO (operands[0])), operands[2])"
+  [(set (mem:QI (pre_dec:HI (reg:HI SP_REGNUM))) (reg:QI D_REGNUM))
+   (set (reg:QI D_REGNUM) (match_dup 1))
+   (set (match_dup 2) (reg:QI D_REGNUM))
+   (set (reg:QI D_REGNUM) (mem:QI (post_inc:HI (reg:HI SP_REGNUM))))
+   (use (reg:HI SP_REGNUM))]
+   "")
+
 ;;
 ;; Reorganize to optimize address computations.
 ;;
@@ -7004,6 +7636,36 @@
   "")
 
 ;;
+;; Replace: "ldx #N; xgdx; addd <var>; xgdx" by "ldab #N; ldx <var>; abx"
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0)
+	         (match_operand:HI 2 "general_operand" "")))
+   (match_scratch:QI 3 "d")]
+  "TARGET_M6811 && (INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0x0ff)"
+  [(set (match_dup 3) (match_dup 4))
+   (set (match_dup 0) (match_dup 2))
+   (set (match_dup 0) (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 0)))]
+  "operands[4] = m68hc11_gen_lowpart (QImode, operands[1]);")
+
+;;
+;; Replace: "ldx #N; xgdx; addd <var>; xgdx" by "ldab #N; ldx <var>; abx"
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0)
+	         (match_operand:HI 2 "general_operand" "")))]
+  "TARGET_M6812"
+  [(set (match_dup 0) (match_dup 2))
+   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]
+  "")
+
+;;
 ;; Optimize an address register increment and a compare to use
 ;; a PRE_INC or PRE_DEC addressing mode (disabled on the tst insn
 ;; before reload, but can be enabled after).
@@ -7095,6 +7757,31 @@
   "")
 
 ;;
+;;
+;;
+(define_peephole2
+  [(parallel 
+     [(set (match_operand:SI 0 "hard_reg_operand" "")
+	(ashift:SI (match_operand:SI 1 "general_operand" "")
+		   (const_int 1)))
+      (clobber (match_scratch:HI 2 ""))])
+   (set (match_operand:HI 3 "nonimmediate_operand" "") (reg:HI D_REGNUM))
+   (set (match_operand:HI 4 "nonimmediate_operand" "") (reg:HI X_REGNUM))]
+  "!X_REG_P (operands[1])
+   && peep2_reg_dead_p (2, gen_rtx (REG, HImode, D_REGNUM))
+   && peep2_reg_dead_p (3, gen_rtx (REG, HImode, X_REGNUM))"
+  [(set (reg:HI D_REGNUM) (match_dup 5))
+   (set (reg:HI D_REGNUM) (ashift:HI (reg:HI D_REGNUM) (const_int 1)))
+   (set (match_dup 3) (reg:HI D_REGNUM))
+   (set (reg:HI D_REGNUM) (match_dup 6))
+   (parallel [(set (reg:HI D_REGNUM)
+		   (rotate:HI (reg:HI D_REGNUM) (const_int 1)))
+              (clobber (reg:HI CC_REGNUM))])
+   (set (match_dup 4) (reg:HI D_REGNUM))]
+  "operands[5] = m68hc11_gen_lowpart (HImode, operands[1]);
+   operands[6] = m68hc11_gen_highpart (HImode, operands[1]);")
+
+;;
 ;; Replace a "ldd <mem>; psha; pshb" with a "ldx <mem>; pshx".
 ;;
 (define_peephole2
@@ -7109,6 +7796,25 @@
   "")
 
 ;;
+;; Remove one load when copying a value to/from memory and also
+;; to a register.  Take care not cloberring a possible register used
+;; by operand 2.
+;; Replace: "ldd 0,y; std 2,y; ldx 0,y" into "ldx 0,y; stx 2,y"
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+        (match_operand:HI 1 "general_operand" ""))
+   (set (match_operand:HI 2 "nonimmediate_operand" "") (match_dup 0))
+   (set (match_operand:HI 3 "hard_reg_operand" "") (match_dup 1))]
+  "peep2_reg_dead_p (2, operands[0])
+   && !side_effects_p (operands[1])
+   && !side_effects_p (operands[2])
+   && !reg_mentioned_p (operands[3], operands[2])"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 2) (match_dup 3))]
+  "")
+
+;;
 ;; Replace a "ldd <mem>; addd #N; std <mem>" into a
 ;; "ldx <mem>; leax; stx <mem>" if we have a free X/Y register
 ;; and the constant is small.
@@ -7131,6 +7837,174 @@
   "if (reg_mentioned_p (operands[4], operands[1])) FAIL;
    if (reg_mentioned_p (operands[4], operands[3])) FAIL;")
 
+;;--------------------------------------------------------------------
+;;- Bset peephole2
+;;--------------------------------------------------------------------
+;; These peepholes try to replace some logical sequences by 'bset' and 'bclr'.
+;;
+;; Replace 'ldab <mem>; orab #N; stab <mem>' by 'bset <mem> #N'.
+;; Register D must be dead and there must be no register side effects for mem.
+;; The <mem> *can* be volatile this is why we must not use 'side_effects_p'.
+;; The good side effect is that it makes the sequence atomic.
+;;
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+	(match_operand:QI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (ior:QI (match_dup 0)
+			      (match_operand:QI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], QImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (ior:QI (match_dup 1) (match_dup 2)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (ior:HI (match_dup 0)
+			      (match_operand:HI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], HImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (ior:HI (match_dup 1) (match_dup 2)))]
+  "")
+
+;;--------------------------------------------------------------------
+;;- Bclr peephole2
+;;--------------------------------------------------------------------
+;; Replace 'ldab <mem>; andab #N; stab <mem>' by 'bclr <mem> #N'.
+;; See Bset peephole2.
+;;
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+	(match_operand:QI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (and:QI (match_dup 0)
+			      (match_operand:QI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], QImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (and:QI (match_dup 1) (match_dup 2)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (and:HI (match_dup 0)
+			      (match_operand:HI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], HImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (and:HI (match_dup 1) (match_dup 2)))]
+  "")
+
+
+;;--------------------------------------------------------------------
+;;- Compare peephole2
+;;--------------------------------------------------------------------
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "hard_reg_operand" ""))
+   (set (match_dup 1) (plus:HI (match_dup 1) 
+                               (match_operand:HI 2 "const_int_operand" "")))
+   (set (cc0) (match_dup 0))]
+  "peep2_reg_dead_p (3, operands[0]) && !Z_REG_P (operands[1])"
+  [(set (match_dup 1) (plus:HI (match_dup 1) (match_dup 2)))
+   (set (cc0) (compare (match_dup 1) (match_dup 2)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "hard_reg_operand" ""))
+   (set (match_operand:HI 2 "hard_reg_operand" "")
+        (plus:HI (match_dup 2) 
+                 (match_operand:HI 3 "const_int_operand" "")))
+   (set (match_operand:HI 4 "memory_operand" "") (match_dup 2))
+   (set (cc0) (match_operand:HI 5 "hard_reg_operand" ""))]
+  "peep2_reg_dead_p (4, operands[5]) && !Z_REG_P (operands[2])
+   && !reg_mentioned_p (operands[2], operands[4])
+
+   && ((rtx_equal_p (operands[5], operands[0])
+        && rtx_equal_p (operands[2], operands[1]))
+
+       || (rtx_equal_p (operands[5], operands[1])
+           && rtx_equal_p (operands[2], operands[0])))"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 2) (plus:HI (match_dup 2) (match_dup 3)))
+   (set (match_dup 4) (match_dup 2))
+   (set (cc0) (compare (match_dup 2) (match_dup 3)))]
+  "")
+
+
+;;--------------------------------------------------------------------
+;;- Load peephole2
+;;--------------------------------------------------------------------
+;;
+;; Optimize initialization of 2 hard regs from the same memory location
+;; Since we can't copy easily X, Y and D to each other, load the 2 registers
+;; from the same memory location.
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:HI 2 "hard_reg_operand" "") (match_dup 0))]
+  "TARGET_M6811
+   && !side_effects_p (operands[1])
+   && !reg_mentioned_p (operands[0], operands[1])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 2) (match_dup 1))]
+  "")
+
+;; Replace "ldd #N; addd <op>" with "ldd <op>; addd #N".
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 1 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 2 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 3 "nonimmediate_operand" "") (const_int 0))
+   (match_scratch:HI 4 "d")]
+  ""
+  [(set (match_dup 4) (const_int 0))
+   (set (match_dup 0) (match_dup 4))
+   (set (match_dup 1) (match_dup 4))
+   (set (match_dup 2) (match_dup 4))
+   (set (match_dup 3) (match_dup 4))]
+  "")
+
+;;
+;; Replace "ldd #N; addd <op>" with "ldd <op>; addd #N".
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 1 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 2 "nonimmediate_operand" "") (const_int 0))
+   (match_scratch:HI 3 "d")]
+  ""
+  [(set (match_dup 3) (const_int 0))
+   (set (match_dup 0) (match_dup 3))
+   (set (match_dup 1) (match_dup 3))
+   (set (match_dup 2) (match_dup 3))]
+  "")
+
+;;
+;; Replace "ldd #N; addd <op>" with "ldd <op>; addd #N".
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "") (const_int 0))
+   (set (match_operand:HI 1 "push_operand" "") (match_dup 0))
+   (set (match_operand:HI 2 "push_operand" "") (match_dup 0))
+   (set (match_operand:HI 3 "push_operand" "") (match_dup 0))
+   (match_scratch:HI 4 "x")]
+  "TARGET_M6811 && D_REG_P (operands[0]) && peep2_reg_dead_p (4, operands[0])"
+  [(set (match_dup 4) (const_int 0))
+   (set (match_dup 1) (match_dup 4))
+   (set (match_dup 2) (match_dup 4))
+   (set (match_dup 3) (match_dup 4))]
+  "")
+
 ;;
 ;; This peephole catches the address computations generated by the reload
 ;; pass. 
@@ -7189,6 +8063,8 @@
 }
 ")
 
+;; SCz 2005-04-03: this peephole is not valid anymore because it appears
+;; we can't rely on the REG_DEAD note
 (define_peephole
   [(set (match_operand:HI 0 "hard_reg_operand" "h")
 	(match_operand:HI 1 "non_push_operand" "g"))
@@ -7279,7 +8155,7 @@
 
 ;;;
 ;;; Catch an xgdx/xgdy followed by a (set D X/Y). If X/Y is dead, we don't
-;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.
+;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.
 ;;;
 (define_peephole
   [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 "hard_reg_operand" "A"))
@@ -7295,7 +8171,7 @@
 
 ;;;
 ;;; Catch an xgdx/xgdy followed by a (set D X/Y). If X/Y is dead, we don't
-;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.
+;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.
 ;;;
 (define_peephole
   [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 "hard_reg_operand" "A"))
@@ -7400,3 +8276,41 @@
   return \"sts\\t%t0\\n\\tld%0\\t%t0\";
 }
 ")
+
+(define_peephole
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:HI 2 "hard_reg_operand" "") (match_dup 0))]
+  "TARGET_M6811
+   && !side_effects_p (operands[1])
+   && !reg_mentioned_p (operands[0], operands[1])"
+  "*
+{
+  rtx ops[2];
+
+  ops[0] = operands[0];
+  ops[1] = operands[1];
+  m68hc11_gen_movhi (insn, ops);
+  ops[0] = operands[2];
+  m68hc11_gen_movhi (insn, ops);
+  return \"\";
+}")
+
+;; Peephole for Z register replacement.
+;; Avoid to use _.tmp register when comparing D and X if we can compare
+;; with soft register
+(define_peephole
+  [(set (match_operand:HI 0 "hard_reg_operand" "") (reg:HI SOFT_XY_REGNUM))
+   (set (reg:HI SOFT_TMP_REGNUM) (match_dup 0))
+   (set (cc0) (compare (match_operand:HI 2 "hard_reg_operand" "")
+                       (reg:HI SOFT_TMP_REGNUM)))]
+  "X_REG_P (operands[0]) || Y_REG_P (operands[0])"
+  "*
+{
+  rtx ops[2];
+
+  ops[0] = operands[0];
+  ops[1] = operands[1];
+  m68hc11_gen_movhi (insn, ops);
+  return \"cp%2\\t%1\";
+}")
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m68hc11-protos.h gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11-protos.h
--- gcc-3.3.6/gcc/config/m68hc11/m68hc11-protos.h	2016-12-11 19:32:34.670647776 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc11-protos.h	2016-12-11 19:32:40.894702914 +0100
@@ -1,5 +1,6 @@
 /* Prototypes for exported functions defined in m68hc11.c
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003,
+   2005, 2006 Free Software Foundation, Inc.
    Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
 This file is part of GNU CC.
@@ -24,7 +25,7 @@ extern int m68hc11_override_options PARA
 extern int m68hc11_optimization_options PARAMS((int,int));
 extern void m68hc11_conditional_register_usage PARAMS((void));
 extern int hard_regno_mode_ok PARAMS((int, enum machine_mode));
-extern int m68hc11_hard_regno_rename_ok PARAMS((int, int));
+extern int m68hc11_hard_regno_rename_ok PARAMS((int, int, int));
 
 extern int m68hc11_total_frame_size PARAMS((void));
 extern int m68hc11_initial_frame_pointer_offset PARAMS((void));
@@ -105,6 +106,7 @@ extern int go_if_legitimate_address2 PAR
 extern int reg_or_indexed_operand PARAMS((rtx,enum machine_mode));
 extern int tst_operand PARAMS((rtx,enum machine_mode));
 extern int cmp_operand PARAMS((rtx,enum machine_mode));
+extern int nonimmediate_noinc_operand PARAMS((rtx,enum machine_mode));
 extern int memory_indexed_operand PARAMS((rtx, enum machine_mode));
 
 extern void m68hc11_split_logical PARAMS((enum machine_mode, int, rtx*));
@@ -147,6 +149,7 @@ extern void m68hc11_function_epilogue PA
 
 extern int m68hc11_is_far_symbol PARAMS((rtx));
 extern int m68hc11_is_trap_symbol PARAMS((rtx));
+extern int m68hc11_page0_symbol_p (rtx x);
 
 #endif /* TREE_CODE */
 
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m68hc12.h gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc12.h
--- gcc-3.3.6/gcc/config/m68hc11/m68hc12.h	2016-12-11 19:32:34.678647847 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m68hc12.h	2016-12-11 19:32:40.902702985 +0100
@@ -19,11 +19,13 @@ along with GNU CC; see the file COPYING.
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-/* Compile and assemble for a 68hc12 unless there is a -m68hc11 option.  */
+/* Default to compile and assemble for a 68hc12 */
 #define ASM_SPEC                                                \
 "%{m68hc11:-m68hc11}"                                           \
+"%{m6812:-m68hc12}"                                         \
 "%{m68hcs12:-m68hcs12}"                                         \
-"%{!m68hc11:%{!m68hcs12:-m68hc12}}"
+"%{m9s12x:-mm9s12x}"                                         \
+"%{!m68hc11:%{!m68hcs12:%{!m9s12x:-m68hc12}}}"
 #define LIB_SPEC       ""
 #define CC1_SPEC       ""
 
@@ -31,19 +33,23 @@ Boston, MA 02111-1307, USA.  */
    emulation option.  This can be overriden by -Wl option of gcc.  */
 #define LINK_SPEC                                               \
 "%{m68hc11:-m m68hc11elf}"                                      \
+"%{m9s12x:-m m9s12xelf}"                                     \
 "%{m68hcs12:-m m68hc12elf}"                                     \
-"%{!m68hc11:%{!m68hcs12:-m m68hc11elf}} %{mrelax:-relax}"
+"%{!m68hc11:%{!m68hcs12:%{!m9s12x:-m m68hc11elf}} %{mrelax:-relax}"
 
 #define CPP_SPEC  \
 "%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16}\
  %{!mshort:-D__INT__=32}\
  %{m68hc11:-Dmc6811 -DMC6811 -Dmc68hc11}\
- %{!m68hc11:%{!m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}}\
+ %{m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}\
+ %{m9s12x:-Dmc6812 -DMC6812 -Dmc68hcs12 -Dm9s12x}\
  %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hcs12}\
- %{!m68hc11:-Dmc6812 -DMC6812 -Dmc68hc12}\
+ %{!m68hc11:%{!m68hc12:%{!m9s12x:-Dmc6812 -DMC6812 -Dmc68hc12 -m68hc12}}}\
  %{fshort-double:-D__HAVE_SHORT_DOUBLE__}"
 
 /* Default target_flags if no switches specified.  */
 #define TARGET_DEFAULT		(MASK_M6812)
 
 #define TARGET_M68HC12
+
+#define CPP_PREDEFINES		"-Dmc68hc1x -Dtarget12"
diff -rupN gcc-3.3.6/gcc/config/m68hc11/m9s12x.h gcc-3.3.6-s12x/gcc/config/m68hc11/m9s12x.h
--- gcc-3.3.6/gcc/config/m68hc11/m9s12x.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/m9s12x.h	2016-12-11 19:32:40.902702985 +0100
@@ -0,0 +1,59 @@
+/* Definitions of target machine for GNU compiler, for m68hc12.
+   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
+   Contributed by Stephane Carrez (stcarrez@nerim.fr).
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Default to compile and assemble for a m9s12x */
+#define ASM_SPEC                                                \
+"%{m68hc11:-m68hc11}"                                           \
+"%{m6812:-m68hc12}"                                         \
+"%{m9s12x:-mm9s12x}"                                         \
+"%{m68hcs12:-m68hcs12}"                                         \
+"%{!m68hc11:%{!m68hcs12:%{!m68hc12: -mm9s12x}}}"
+/* last line was "%{!m68hc11:%{!m68hcs12:%{!m68hc12:%{!m9s12x:-mm9s12x}}}}" */
+#define LIB_SPEC       ""
+#define CC1_SPEC       ""
+
+/* We need to tell the linker the target elf format.  Just pass an
+   emulation option.  This can be overriden by -Wl option of gcc.  */
+#define LINK_SPEC                                               \
+"%{m68hc11:-m m68hc11elf}"                                      \
+"%{m9s12x:-m m68hc12elf}"                                     \
+"%{m68hcs12:-m m68hc12elf}"                                     \
+"%{!m68hc11:%{!m68hcs12:%{!m9s12x:-m m68hc11elf}}} %{mrelax:-relax}"
+
+#define CPP_SPEC  \
+"%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16}\
+ %{!mshort:-D__INT__=32}\
+ %{m68hc11:-Dmc68hc11}\
+ %{m68hc12:-Dmc68hc12 -Dm68hc12}\
+ %{m9s12x:-Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}\
+ %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hc12 -Dmc68hcs12}\
+ %{!m68hc11:%{!m68hc12:%{!m68hcs12:-Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}}}\
+ %{fshort-double:-D__HAVE_SHORT_DOUBLE__}"
+/* penultimate was %{!m68hc11:%{!m68hc12:%{!m68hcs12:%{!m9s12x:-Dmc6812 -DMC6812 -Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}}}} */
+
+/* Default target_flags if no switches specified. Just causes problems if defaulting to S12X */
+#define TARGET_DEFAULT		(MASK_M6812)
+
+#define TARGET_M68HC12
+
+#define MULTILIB_DEFAULTS { "m9s12x" }
+
+#define CPP_PREDEFINES		"-Dmc68hc1x -Dtargets12x"
diff -rupN gcc-3.3.6/gcc/config/m68hc11/t-m68hc11-gas gcc-3.3.6-s12x/gcc/config/m68hc11/t-m68hc11-gas
--- gcc-3.3.6/gcc/config/m68hc11/t-m68hc11-gas	2016-12-11 19:32:34.678647847 +0100
+++ gcc-3.3.6-s12x/gcc/config/m68hc11/t-m68hc11-gas	2016-12-11 19:32:40.902702985 +0100
@@ -31,13 +31,14 @@ TARGET_LIBGCC2_CFLAGS = -DUSE_GAS -DIN_G
 
 # C implementation of 32-bit div/mod.
 LIB2FUNCS_EXTRA = $(srcdir)/config/udivmodsi4.c \
-	$(srcdir)/config/divmod.c $(srcdir)/config/udivmod.c
+	$(srcdir)/config/divmod.c $(srcdir)/config/udivmod.c \
+	$(srcdir)/config/m68hc11/ldivmod.asm
 
 # Don't compile with -g1 this reduces the size of some sections (.eh_frame).
 LIBGCC2_DEBUG_CFLAGS =-g
-LIBGCC2_CFLAGS = -Os -mrelax $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2
-
-MULTILIB_OPTIONS  = m68hc11/m68hc12 mshort fshort-double
+LIBGCC2_CFLAGS = -O -mrelax $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2
+# -m9s12x 
+MULTILIB_OPTIONS  = m68hc11/m68hc12/m9s12x mshort fshort-double mlong-calls
 MULTILIB_DIRNAMES =
 MULTILIB_MATCHES  = m68hc11=m6811 m68hc12=m6812 m68hc12=m68hcs12
 MULTILIB_EXCEPTIONS = -mnoshort -mno68hc11
diff -rupN gcc-3.3.6/gcc/config/udivmod.c gcc-3.3.6-s12x/gcc/config/udivmod.c
--- gcc-3.3.6/gcc/config/udivmod.c	2016-12-11 19:32:34.682647882 +0100
+++ gcc-3.3.6-s12x/gcc/config/udivmod.c	2016-12-11 19:32:40.902702985 +0100
@@ -1,14 +1,36 @@
-long udivmodsi4 ();
+/* cover the root directory case */
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+#if defined(target11)
+#define mc68hc11
+#endif
+#if defined(target12)
+#define mc68hc12
+#endif
+#if defined(targets12x)
+#define m9s12x
+#define mc68hc12
+#endif
+#endif
 
-long
-__udivsi3 (long a, long b)
+#ifndef mc68hc12
+extern unsigned long __udivmodsi4 (unsigned long num, unsigned long den,
+                                   unsigned long *mod);
+
+unsigned long
+__inline __udivsi3 (unsigned long a, unsigned long b)
 {
-  return udivmodsi4 (a, b, 0);
+  return __udivmodsi4 (a, b, 0);
 }
 
-long
-__umodsi3 (long a, long b)
+unsigned long
+__inline __umodsi3 (unsigned long a, unsigned long b)
 {
-  return udivmodsi4 (a, b, 1);
+  unsigned long mod;
+
+  __udivmodsi4 (a, b, &mod);
+  return mod;
 }
 
+
+
+#endif /* !mc68hc12 */
diff -rupN gcc-3.3.6/gcc/config/udivmodsi4.c gcc-3.3.6-s12x/gcc/config/udivmodsi4.c
--- gcc-3.3.6/gcc/config/udivmodsi4.c	2016-12-11 19:32:34.682647882 +0100
+++ gcc-3.3.6-s12x/gcc/config/udivmodsi4.c	2016-12-11 19:32:40.902702985 +0100
@@ -1,10 +1,71 @@
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+#if defined(target11)
+#define mc68hc11
+#endif
+#if defined(target12)
+#define mc68hc12
+#endif
+#if defined(targets12x)
+#define m9s12x
+#define mc68hc12
+#endif
+#endif
+
+#ifndef mc68hc12
 unsigned long
-udivmodsi4(unsigned long num, unsigned long den, int modwanted)
+__udivmodsi4 (unsigned long num, unsigned long den, unsigned long* mod)
 {
-  unsigned long bit = 1;
-  unsigned long res = 0;
+  unsigned long bit;
+  unsigned long res;
+  
+  if ((unsigned short) (den >> 16) == 0)
+    {
+#ifdef mc68hc11
+      if ((unsigned short) (num >> 16) == 0)
+        {
+          /* Both numbers are 16-bit quantities, use 16-bit div/mod.  */
+          unsigned short sden = (unsigned short) den;
+          unsigned short snum = (unsigned short) num;
+          unsigned short sres = snum / sden;
+          unsigned short smod = snum % sden;;
 
-  while (den < num && bit && !(den & (1L<<31)))
+          if (mod)
+            *mod = (unsigned long) smod;
+          return (unsigned long) sres;
+        }
+#endif
+#ifdef mc68hc12
+        {
+          /* To avoid to stress the gcc reload, use + operand modifier
+             and pass the input values in the same variables as the
+             outputs.  */
+          unsigned short status = (unsigned short) den;
+          unsigned short smod = (unsigned short) (num & 0x0ffff);
+          unsigned short sres = (unsigned short) (num >> 16);
+
+          __asm__ __volatile__ ("ediv\n"
+                                "tfr ccr,x"
+                                : "+x" (status), "+y" (sres),
+                                  "+d" (smod));
+          /* check for overflow */
+          if (!(status & 0x03))
+            {
+              if (mod)
+                *mod = (unsigned long) smod;
+              return (unsigned long) sres;
+            }
+        }
+#endif
+      if ((unsigned short) den == 0)
+        {
+          if (mod)
+            *mod = 0;
+          return 0;
+        }
+    }
+  bit = 1;
+  res = 0;
+  while (den < num && !((unsigned short) (den >> 16) & (1L<<15)))
     {
       den <<=1;
       bit <<=1;
@@ -19,6 +80,28 @@ udivmodsi4(unsigned long num, unsigned l
       bit >>=1;
       den >>=1;
     }
-  if (modwanted) return num;
+  if (mod)
+    *mod = num;
   return res;
 }
+
+#ifdef L_udivmodsi4
+unsigned long
+udivmodsi4 (unsigned long num, unsigned long den, int modwanted)
+{
+  unsigned long mod;
+
+  if (modwanted)
+    {
+      __udivmodsi4 (num, den, &mod);
+      return mod;
+    }
+  else
+    {
+      return __udivmodsi4 (num, den, 0);
+    }
+}
+#endif
+
+#endif /*!mc68hc12 */
+
diff -rupN gcc-3.3.6/gcc/cppdefault.c gcc-3.3.6-s12x/gcc/cppdefault.c
--- gcc-3.3.6/gcc/cppdefault.c	2016-12-11 19:32:34.682647882 +0100
+++ gcc-3.3.6-s12x/gcc/cppdefault.c	2016-12-11 19:32:40.918703126 +0100
@@ -76,11 +76,15 @@ const struct default_include cpp_include
 
 #ifdef GCC_INCLUDE_DIR
 const char cpp_GCC_INCLUDE_DIR[] = GCC_INCLUDE_DIR;
+#if GNU_HC1X_DONT_PATCH
 const size_t cpp_GCC_INCLUDE_DIR_len = sizeof GCC_INCLUDE_DIR - 8;
+#endif
 #else
 const char cpp_GCC_INCLUDE_DIR[] = "";
+#if GNU_HC1X_DONT_PATCH
 const size_t cpp_GCC_INCLUDE_DIR_len = 0;
 #endif
+#endif
 
 #ifdef TARGET_SYSTEM_ROOT
 const char *cpp_SYSROOT = TARGET_SYSTEM_ROOT;
diff -rupN gcc-3.3.6/gcc/cppdefault.h gcc-3.3.6-s12x/gcc/cppdefault.h
--- gcc-3.3.6/gcc/cppdefault.h	2016-12-11 19:32:34.682647882 +0100
+++ gcc-3.3.6-s12x/gcc/cppdefault.h	2016-12-11 19:32:40.918703126 +0100
@@ -67,7 +67,17 @@ struct default_include
 
 extern const struct default_include cpp_include_defaults[];
 extern const char cpp_GCC_INCLUDE_DIR[];
+
+/* Don't use sizeof GCC_INCLUDE_DIR because for Mingw32 we patch the
+   executable to replace this path with the good path.  We must then
+   use strlen() to find the correct length.  */
+#undef GNU_HC1X_DONT_PATCH
+#if GNU_HC1X_DONT_PATCH
 extern const size_t cpp_GCC_INCLUDE_DIR_len;
+#else
+#define cpp_GCC_INCLUDE_DIR_len \
+(strlen (cpp_GCC_INCLUDE_DIR) > 7 ? strlen (cpp_GCC_INCLUDE_DIR) - 7 : 0)
+#endif
 
 extern const char *cpp_SYSROOT;
 
diff -rupN gcc-3.3.6/gcc/doc/extend.texi gcc-3.3.6-s12x/gcc/doc/extend.texi
--- gcc-3.3.6/gcc/doc/extend.texi	2016-12-11 19:32:34.686647918 +0100
+++ gcc-3.3.6-s12x/gcc/doc/extend.texi	2016-12-11 19:32:40.922703162 +0100
@@ -2528,11 +2528,14 @@ to call and return from a function.
 
 On 68HC11 the compiler will generate a sequence of instructions
 to invoke a board-specific routine to switch the memory bank and call the
-real function. The board-specific routine simulates a @code{call}.
+real function.  The board-specific routine simulates a @code{call}.
 At the end of a function, it will jump to a board-specific routine
-instead of using @code{rts}. The board-specific return routine simulates
+instead of using @code{rts}.  The board-specific return routine simulates
 the @code{rtc}.
 
+The @code{far} attribute must not be used when the @code{interrupt} or
+@code{trap} attributes are used.
+
 @item near
 @cindex functions which do not handle memory bank switching on 68HC11/68HC12
 On 68HC11 and 68HC12 the @code{near} attribute causes the compiler to
@@ -2540,6 +2543,21 @@ use the normal calling convention based
 This attribute can be used to cancel the effect of the @option{-mlong-calls}
 option.
 
+@item page0
+@cindex variables in page0 section for which direct addressing mode can be used
+On 68HC11 and 68HC12, the @code{page0} attribute indicates that a global
+or static variable is put in the @code{page0} section and the compiler can
+use the direct addressing mode.  On 68HC11 the compiler will be able to
+use @code{bset} and @code{bclr} on these variables.  Note that the @code{page0}
+is limited to the absolute address range @code{0}..@code{0x0ff}.
+
+@item trap
+@cindex functions which are used as trap handlers (@code{swi} or @code{trap})
+On 68HC11 and 68HC12, the @code{trap} attribute marks the function as being
+a trap handler.  It will use @code{rti} instead of @code{rts} to return
+from the function.  Offset of function parameters are also adjusted to take
+into account the trap frame.
+
 @item dllimport
 @cindex @code{__declspec(dllimport)}
 On Windows targets, the @code{dllimport} attribute causes the compiler
diff -rupN gcc-3.3.6/gcc/doc/invoke.texi gcc-3.3.6-s12x/gcc/doc/invoke.texi
--- gcc-3.3.6/gcc/doc/invoke.texi	2016-12-11 19:32:34.722648236 +0100
+++ gcc-3.3.6-s12x/gcc/doc/invoke.texi	2016-12-11 19:32:40.930703233 +0100
@@ -329,7 +329,7 @@ in the following sections.
 
 @emph{M68hc1x Options}
 @gccoptlist{-m6811  -m6812  -m68hc11  -m68hc12  -m68hcs12 @gol
--mauto-incdec  -minmax  -mlong-calls  -mshort @gol
+-mauto-incdec  -minmax  -mlong-calls  -mrelax  -mshort @gol
 -msoft-reg-count=@var{count}}
 
 @emph{VAX Options}
@@ -5624,7 +5624,20 @@ Enable the use of 68HC12 min and max ins
 @opindex mno-long-calls
 Treat all calls as being far away (near).  If calls are assumed to be
 far away, the compiler will use the @code{call} instruction to
-call a function and the @code{rtc} instruction for returning.
+call a function and the @code{rtc} instruction for returning.  An interrupt
+or a trap handler is not affected by this option and is always considered near.
+
+@item -mrelax
+@opindex mrelax
+Indicate to the compiler and linker that they should perform a relaxation
+optimization pass to shorten branches, calls and absolute memory addresses.
+The compiler will not use direct addressing mode for pseudo-soft registers and
+it will also emit some @code{bset} and @code{bclr} sequences that can be
+optimized by the linker.  The linker option @option{-relax} will be used
+and the linker will transform 16-bit addressing modes into direct addressing
+modes if possible.
+
+This option makes symbolic debugging impossible.
 
 @item -mshort
 @opindex mshort
diff -rupN gcc-3.3.6/gcc/expmed.c gcc-3.3.6-s12x/gcc/expmed.c
--- gcc-3.3.6/gcc/expmed.c	2016-12-11 19:32:34.730648307 +0100
+++ gcc-3.3.6-s12x/gcc/expmed.c	2016-12-11 19:32:40.934703268 +0100
@@ -474,6 +474,15 @@ store_bit_field (str_rtx, bitsize, bitnu
 	 result in an abort.  */
       fieldmode = smallest_mode_for_size (nwords * BITS_PER_WORD, MODE_INT);
 
+      /* When the value is a constant, the constant_subword applies a
+         correction on big endian targets.  If the bitfield contains less words
+         than the value (fieldmode), the constant that is extracted is shifted
+         by the word difference.  Example: bitfield = 33, fieldmode = DImode
+         and constant_subword extracts word 1 2 3 instead of 0 1 2.  */
+      int correction = 0;
+      if (WORDS_BIG_ENDIAN && CONSTANT_P (value))
+        correction = GET_MODE_BITSIZE (fieldmode) / BITS_PER_WORD - nwords;
+
       for (i = 0; i < nwords; i++)
 	{
 	  /* If I is 0, use the low-order word in both field and target;
@@ -488,7 +497,7 @@ store_bit_field (str_rtx, bitsize, bitnu
 	  store_bit_field (op0, MIN (BITS_PER_WORD,
 				     bitsize - i * BITS_PER_WORD),
 			   bitnum + bit_offset, word_mode,
-			   operand_subword_force (value, wordnum,
+			   operand_subword_force (value, correction + wordnum,
 						  (GET_MODE (value) == VOIDmode
 						   ? fieldmode
 						   : GET_MODE (value))),
@@ -2142,7 +2151,7 @@ synth_mult (alg_out, t, cost_limit)
   if ((t & 1) == 0)
     {
       m = floor_log2 (t & -t);	/* m = number of low zero bits */
-      if (m < BITS_PER_WORD)
+      if (m < MAX_BITS_PER_WORD)
 	{
 	  q = t >> m;
 	  cost = shift_cost[m];
@@ -2227,7 +2236,7 @@ synth_mult (alg_out, t, cost_limit)
       unsigned HOST_WIDE_INT d;
 
       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;
-      if (t % d == 0 && t > d && m < BITS_PER_WORD)
+      if (t % d == 0 && t > d && m < MAX_BITS_PER_WORD)
 	{
 	  cost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);
 	  synth_mult (alg_in, t / d, cost_limit - cost);
@@ -2246,7 +2255,7 @@ synth_mult (alg_out, t, cost_limit)
 	}
 
       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;
-      if (t % d == 0 && t > d && m < BITS_PER_WORD)
+      if (t % d == 0 && t > d && m < MAX_BITS_PER_WORD)
 	{
 	  cost = MIN (shiftsub_cost[m], add_cost + shift_cost[m]);
 	  synth_mult (alg_in, t / d, cost_limit - cost);
@@ -2271,7 +2280,7 @@ synth_mult (alg_out, t, cost_limit)
       q = t - 1;
       q = q & -q;
       m = exact_log2 (q);
-      if (m >= 0 && m < BITS_PER_WORD)
+      if (m >= 0 && m < MAX_BITS_PER_WORD)
 	{
 	  cost = shiftadd_cost[m];
 	  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost);
@@ -2290,7 +2299,7 @@ synth_mult (alg_out, t, cost_limit)
       q = t + 1;
       q = q & -q;
       m = exact_log2 (q);
-      if (m >= 0 && m < BITS_PER_WORD)
+      if (m >= 0 && m < MAX_BITS_PER_WORD)
 	{
 	  cost = shiftsub_cost[m];
 	  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost);
@@ -2793,7 +2802,7 @@ expand_mult_highpart (mode, op0, cnst1,
 
   /* expand_mult handles constant multiplication of word_mode
      or narrower.  It does a poor job for large modes.  */
-  if (size < BITS_PER_WORD
+  if (size < MAX_BITS_PER_WORD
       && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)
     {
       /* We have to do this, since expand_binop doesn't do conversion for
@@ -2824,7 +2833,7 @@ expand_mult_highpart (mode, op0, cnst1,
 
   /* Secondly, same as above, but use sign flavor opposite of unsignedp.
      Need to adjust the result after the multiplication.  */
-  if (size - 1 < BITS_PER_WORD
+  if (size - 1 < MAX_BITS_PER_WORD
       && (mul_highpart_cost[(int) mode] + 2 * shift_cost[size-1] + 4 * add_cost
 	  < max_cost))
     {
@@ -2849,7 +2858,7 @@ expand_mult_highpart (mode, op0, cnst1,
   /* Try widening the mode and perform a non-widening multiplication.  */
   moptab = smul_optab;
   if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing
-      && size - 1 < BITS_PER_WORD
+      && size - 1 < MAX_BITS_PER_WORD
       && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)
     {
       op1 = wide_op1;
@@ -2859,7 +2868,7 @@ expand_mult_highpart (mode, op0, cnst1,
   /* Try widening multiplication of opposite signedness, and adjust.  */
   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;
   if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing
-      && size - 1 < BITS_PER_WORD
+      && size - 1 < MAX_BITS_PER_WORD
       && (mul_widen_cost[(int) wider_mode]
 	  + 2 * shift_cost[size-1] + 4 * add_cost < max_cost))
     {
@@ -3199,7 +3208,7 @@ expand_divmod (rem_flag, code, mode, op0
 			  {
 			    rtx t1, t2, t3, t4;
 
-			    if (post_shift - 1 >= BITS_PER_WORD)
+			    if (post_shift - 1 >= MAX_BITS_PER_WORD)
 			      goto fail1;
 
 			    extra_cost = (shift_cost[post_shift - 1]
@@ -3226,8 +3235,8 @@ expand_divmod (rem_flag, code, mode, op0
 			  {
 			    rtx t1, t2;
 
-			    if (pre_shift >= BITS_PER_WORD
-				|| post_shift >= BITS_PER_WORD)
+			    if (pre_shift >= MAX_BITS_PER_WORD
+				|| post_shift >= MAX_BITS_PER_WORD)
 			      goto fail1;
 
 			    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,
@@ -3363,8 +3372,8 @@ expand_divmod (rem_flag, code, mode, op0
 		      {
 			rtx t1, t2, t3;
 
-			if (post_shift >= BITS_PER_WORD
-			    || size - 1 >= BITS_PER_WORD)
+			if (post_shift >= MAX_BITS_PER_WORD
+			    || size - 1 >= MAX_BITS_PER_WORD)
 			  goto fail1;
 
 			extra_cost = (shift_cost[post_shift]
@@ -3393,8 +3402,8 @@ expand_divmod (rem_flag, code, mode, op0
 		      {
 			rtx t1, t2, t3, t4;
 
-			if (post_shift >= BITS_PER_WORD
-			    || size - 1 >= BITS_PER_WORD)
+			if (post_shift >= MAX_BITS_PER_WORD
+			    || size - 1 >= MAX_BITS_PER_WORD)
 			  goto fail1;
 
 			ml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);
@@ -3480,8 +3489,8 @@ expand_divmod (rem_flag, code, mode, op0
 		    if (mh)
 		      abort ();
 
-		    if (post_shift < BITS_PER_WORD
-			&& size - 1 < BITS_PER_WORD)
+		    if (post_shift < MAX_BITS_PER_WORD
+			&& size - 1 < MAX_BITS_PER_WORD)
 		      {
 			t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,
 					   build_int_2 (size - 1, 0),
@@ -4135,8 +4144,12 @@ make_tree (type, x)
 
     case SIGN_EXTEND:
     case ZERO_EXTEND:
-      t = (*lang_hooks.types.type_for_mode) (GET_MODE (XEXP (x, 0)),
-					     GET_CODE (x) == ZERO_EXTEND);
+      if (CONSTANT_P (XEXP (x, 0)))
+        t = (*lang_hooks.types.type_for_mode) (GET_MODE (x),
+					       GET_CODE (x) == ZERO_EXTEND);
+      else
+        t = (*lang_hooks.types.type_for_mode) (GET_MODE (XEXP (x, 0)),
+					       GET_CODE (x) == ZERO_EXTEND);
       return fold (convert (type, make_tree (t, XEXP (x, 0))));
 
    default:
diff -rupN gcc-3.3.6/gcc/final.c gcc-3.3.6-s12x/gcc/final.c
--- gcc-3.3.6/gcc/final.c	2016-12-11 19:32:34.734648343 +0100
+++ gcc-3.3.6-s12x/gcc/final.c	2016-12-11 19:32:40.938703304 +0100
@@ -2909,7 +2909,22 @@ alter_subreg (xp)
   /* simplify_subreg does not remove subreg from volatile references.
      We are required to.  */
   if (GET_CODE (y) == MEM)
-    *xp = adjust_address (y, GET_MODE (x), SUBREG_BYTE (x));
+    {
+      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));
+      unsigned inner_size = GET_MODE_SIZE (GET_MODE (y));
+      int offset = SUBREG_BYTE (x);
+      
+      /* If this is a paradoxical subreg with a SUBREG_BYTE set
+         to 0 we must adjust the offset for big-endian machines
+         (otherwise we take the address of the high part).  */
+      if (BYTES_BIG_ENDIAN && !offset && outer_size > inner_size)
+        {
+          offset += MIN (inner_size, UNITS_PER_WORD);
+          offset -= MIN (outer_size, UNITS_PER_WORD);
+        }
+
+      *xp = adjust_address (y, GET_MODE (x), offset);
+    }
   else
     {
       rtx new = simplify_subreg (GET_MODE (x), y, GET_MODE (y),
diff -rupN gcc-3.3.6/gcc/flow.c gcc-3.3.6-s12x/gcc/flow.c
--- gcc-3.3.6/gcc/flow.c	2016-12-11 19:32:34.738648378 +0100
+++ gcc-3.3.6-s12x/gcc/flow.c	2016-12-11 19:32:40.938703304 +0100
@@ -571,7 +571,7 @@ verify_local_live_at_start (new_live_at_
 	      fputs ("Old:\n", rtl_dump_file);
 	      dump_bb (bb, rtl_dump_file);
 	    }
-	  abort ();
+	  // SCz: abort ();
 	}
     }
   else
diff -rupN gcc-3.3.6/gcc/gcse.c gcc-3.3.6-s12x/gcc/gcse.c
--- gcc-3.3.6/gcc/gcse.c	2016-12-11 19:32:34.742648414 +0100
+++ gcc-3.3.6-s12x/gcc/gcse.c	2016-12-11 19:32:40.942703339 +0100
@@ -3513,8 +3513,7 @@ handle_avail_expr (insn, expr)
       /* ??? If the change fails, we return 0, even though we created
 	 an insn.  I think this is ok.  */
       new_insn
-	= emit_insn_after (gen_rtx_SET (VOIDmode, to,
-					SET_DEST (expr_set)),
+	= emit_insn_after (gen_move_insn (to, SET_DEST (expr_set)),
 			   insn_computes_expr);
 
       /* Keep register set table up to date.  */
@@ -3525,7 +3524,7 @@ handle_avail_expr (insn, expr)
 	{
 	  fprintf (gcse_file, "GCSE: Creating insn %d to copy value of reg %d",
 		   INSN_UID (NEXT_INSN (insn_computes_expr)),
-		   REGNO (SET_SRC (PATTERN (NEXT_INSN (insn_computes_expr)))));
+		   REGNO (SET_DEST (expr_set)));
 	  fprintf (gcse_file, ", computed in insn %d,\n",
 		   INSN_UID (insn_computes_expr));
 	  fprintf (gcse_file, "      into newly allocated reg %d\n",
diff -rupN gcc-3.3.6/gcc/libgcc2.c gcc-3.3.6-s12x/gcc/libgcc2.c
--- gcc-3.3.6/gcc/libgcc2.c	2016-12-11 19:32:34.742648414 +0100
+++ gcc-3.3.6-s12x/gcc/libgcc2.c	2016-12-11 19:32:40.966703552 +0100
@@ -490,7 +490,12 @@ __udiv_w_sdiv (UWtype *rp __attribute__
 
 #if (defined (L_udivdi3) || defined (L_divdi3) || \
      defined (L_umoddi3) || defined (L_moddi3))
-#define L_udivmoddi4
+#if !defined(mc6811) && !defined(mc6812)
+# define L_udivmoddi4
+#else
+extern UDWtype
+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp);
+#endif
 #endif
 
 #ifdef L_clz
diff -rupN gcc-3.3.6/gcc/longlong.h gcc-3.3.6-s12x/gcc/longlong.h
--- gcc-3.3.6/gcc/longlong.h	2016-12-11 19:32:34.742648414 +0100
+++ gcc-3.3.6-s12x/gcc/longlong.h	2016-12-11 19:32:40.970703587 +0100
@@ -1162,6 +1162,67 @@ UDItype __umulsidi3 (USItype, USItype);
 
 #endif /* __GNUC__ */
 
+#if defined(mc6811) || defined(mc6812)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl)				\
+  do {									\
+    __asm__ ("subd 2+%2\n"						\
+             "\txgdx\n"							\
+             "\tsbcb 1+%2\n"						\
+             "\tsbca %2\n"						\
+             "\txgdx" : "=D"((USItype) (sl))				\
+		      : "0"((USItype) (al)), "m"((USItype) (bl)));	\
+    /* Assumes that the carry is not modified. */			\
+    /* which is true since the reload instructions */			\
+    /* generated between the two __asm__ only do load/store.  */	\
+    __asm__ ("sbcb 3+%2\n"						\
+             "\tsbca 2+%2\n"						\
+             "\txgdx\n"							\
+             "\tsbcb 1+%2\n"						\
+             "\tsbca %2\n"						\
+             "\txgdx" : "=D"((USItype) (sh))				\
+		      : "0"((USItype) (ah)), "m"((USItype) (bh)));	\
+  } while (0)
+#if defined(mc6812)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+									\
+    __x0 = ((UWtype) ((UHItype) __ll_lowpart (u))) * ((UWtype) ((UHItype) __ll_lowpart (v)));	\
+    __x1 = ((UWtype) ((UHItype) __ll_lowpart (u))) * ((UWtype) ((UHItype) __ll_highpart (v)));	\
+    __x2 = ((UWtype) ((UHItype) __ll_highpart (u))) * ((UWtype) ((UHItype) __ll_lowpart (v)));	\
+    __x3 = ((UWtype) ((UHItype) __ll_highpart (u))) * ((UWtype) ((UHItype) __ll_highpart (v)));	\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    __asm__ ("bcc 1f\n"                                                 \
+	     "\tinx\n"							\
+	     "1:" : "=D"(__x3) : "0"(__x3));				\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+#else
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+    extern UWtype __attribute__((near)) __mulhi32 (UHItype, UHItype);	\
+									\
+    __x0 = __mulhi32 (__ll_lowpart (u), __ll_lowpart (v));		\
+    __x1 = __mulhi32 (__ll_lowpart (u), __ll_highpart (v));		\
+    __x2 = __mulhi32 (__ll_highpart (u), __ll_lowpart (v));		\
+    __x3 = __mulhi32 (__ll_highpart (u), __ll_highpart (v));		\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    __asm__ ("bcc 1f\n"                                                 \
+	     "\tinx\n"							\
+	     "1:" : "=D"(__x3) : "0"(__x3));				\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+#endif
+#endif     
 /* If this machine has no inline assembler, use C macros.  */
 
 #if !defined (add_ssaaaa)
@@ -1232,6 +1293,45 @@ UDItype __umulsidi3 (USItype, USItype);
 #endif
 
 /* Define this unconditionally, so it can be used for debugging.  */
+#if defined(mc6811) || defined(mc6812)
+extern USItype __udivmodsi4(USItype num, USItype den, USItype* mod);
+
+#define __udiv_qrnnd_c(q, r, n1, n0, d) \
+  do {									\
+    USItype __d1, __d0, __q1, __q0;					\
+    USItype __r0, __m;						\
+    __d1 = __ll_highpart (d);						\
+    __d0 = __ll_lowpart (d);						\
+									\
+    __q1 = __udivmodsi4 (n1,__d1,&__r0);				\
+    __m = (USItype) __q1 * __d0;					\
+    __r0 = __r0 * __ll_B | __ll_highpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q1--, __r0 += (d);						\
+	if (__r0 >= (d)) /* i.e. we didn't get carry when adding to __r0 */\
+	  if (__r0 < __m)						\
+	    __q1--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    __q0 = __udivmodsi4 (__r0,__d1,&__r0);				\
+    __m = (USItype) __q0 * __d0;					\
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q0--, __r0 += (d);						\
+	if (__r0 >= (d))						\
+	  if (__r0 < __m)						\
+	    __q0--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    (q) = (USItype) __q1 * __ll_B | __q0;				\
+    (r) = __r0;								\
+  } while (0)
+#else
+/* Define this unconditionally, so it can be used for debugging.  */
 #define __udiv_qrnnd_c(q, r, n1, n0, d) \
   do {									\
     UWtype __d1, __d0, __q1, __q0;					\
@@ -1268,6 +1368,7 @@ UDItype __umulsidi3 (USItype, USItype);
     (q) = (UWtype) __q1 * __ll_B | __q0;				\
     (r) = __r0;								\
   } while (0)
+#endif
 
 /* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through
    __udiv_w_sdiv (defined in libgcc or elsewhere).  */
diff -rupN gcc-3.3.6/gcc/loop.c gcc-3.3.6-s12x/gcc/loop.c
--- gcc-3.3.6/gcc/loop.c	2016-12-11 19:32:34.754648520 +0100
+++ gcc-3.3.6-s12x/gcc/loop.c	2016-12-11 19:32:40.974703623 +0100
@@ -4703,7 +4703,8 @@ loop_givs_reduce (loop, bl)
 	     this is an address giv, then try to put the increment
 	     immediately after its use, so that flow can create an
 	     auto-increment addressing mode.  */
-	  if (v->giv_type == DEST_ADDR && bl->biv_count == 1
+	  if ((HAVE_POST_INCREMENT || HAVE_POST_DECREMENT)
+              && v->giv_type == DEST_ADDR && bl->biv_count == 1
 	      && bl->biv->always_executed && ! bl->biv->maybe_multiple
 	      /* We don't handle reversed biv's because bl->biv->insn
 		 does not have a valid INSN_LUID.  */
@@ -8979,7 +8980,13 @@ maybe_eliminate_biv_1 (loop, x, insn, bl
 		    || (GET_CODE (v->add_val) == REG
 			&& REG_POINTER (v->add_val)))
 		&& ! v->ignore && ! v->maybe_dead && v->always_computable
-		&& v->mode == mode)
+		&& v->mode == mode
+                /* SCz: There is a possible overflow here.
+                   If we compare to a constant value, the constant is
+                   re-computed (CST * mult_add + add_val) and there may
+                   be an overflow. CST was 16399, mult was 8, and integers
+                   are 16-bits.   (execute/loop-3c.c, -Os -mshort).  */
+                && 0)
 	      {
 		if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))
 		  continue;
diff -rupN gcc-3.3.6/gcc/regrename.c gcc-3.3.6-s12x/gcc/regrename.c
--- gcc-3.3.6/gcc/regrename.c	2016-12-11 19:32:34.754648520 +0100
+++ gcc-3.3.6-s12x/gcc/regrename.c	2016-12-11 19:32:40.974703623 +0100
@@ -102,6 +102,9 @@ note_sets (x, set, data)
   HARD_REG_SET *pset = (HARD_REG_SET *) data;
   unsigned int regno;
   int nregs;
+
+  if (GET_CODE (x) == SUBREG)
+    x = SUBREG_REG (x);
   if (GET_CODE (x) != REG)
     return;
   regno = REGNO (x);
@@ -292,6 +295,7 @@ regrename_optimize ()
 	  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)
 	    {
 	      int nregs = HARD_REGNO_NREGS (new_reg, GET_MODE (*this->loc));
+              int mode = GET_MODE (*this->loc);
 
 	      for (i = nregs - 1; i >= 0; --i)
 	        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)
@@ -307,7 +311,7 @@ regrename_optimize ()
 			&& !LEAF_REGISTERS[new_reg + i])
 #endif
 #ifdef HARD_REGNO_RENAME_OK
-		    || ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i)
+		    || ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i, mode)
 #endif
 		    )
 		  break;
diff -rupN gcc-3.3.6/gcc/reload1.c gcc-3.3.6-s12x/gcc/reload1.c
--- gcc-3.3.6/gcc/reload1.c	2016-12-11 19:32:34.766648626 +0100
+++ gcc-3.3.6-s12x/gcc/reload1.c	2016-12-11 19:32:40.986703729 +0100
@@ -1777,9 +1777,6 @@ find_reg (chain, order)
   if (best_reg == -1)
     return 0;
 
-  if (rtl_dump_file)
-    fprintf (rtl_dump_file, "Using reg %d for reload %d\n", best_reg, rnum);
-
   rl->nregs = HARD_REGNO_NREGS (best_reg, rl->mode);
   rl->regno = best_reg;
 
@@ -1930,6 +1927,7 @@ spill_failure (insn, class)
     {
       error ("unable to find a register to spill in class `%s'",
 	     reg_class_names[class]);
+
       fatal_insn ("this is the insn:", insn);
     }
 }
@@ -3979,7 +3977,7 @@ reload_as_needed (live_known)
 	     for this insn in order to be stored in
 	     (obeying register constraints).  That is correct; such reload
 	     registers ARE still valid.  */
-	  note_stores (oldpat, forget_old_reloads_1, NULL);
+         note_stores (oldpat, forget_old_reloads_1, NULL);
 
 	  /* There may have been CLOBBER insns placed after INSN.  So scan
 	     between INSN and NEXT and use them to forget old reloads.  */
@@ -4580,6 +4578,9 @@ reload_reg_reaches_end_p (regno, opnum,
     case RELOAD_OTHER:
       /* Since a RELOAD_OTHER reload claims the reg for the entire insn,
 	 its value must reach the end.  */
+      for (i = 0; i < reload_n_operands; i++)
+        if (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))
+          return 0;
       return 1;
 
       /* If this use is for part of the insn,
@@ -5298,6 +5299,13 @@ choose_reload_regs_init (chain, save_rel
   CLEAR_HARD_REG_SET (reload_reg_used_in_insn);
   CLEAR_HARD_REG_SET (reload_reg_used_in_other_addr);
 
+#if 0 /* TARGET_M68HC11 or NO_SPILL_REG_ROUND_ROBIN */
+  /* Don't use the round-robin fashion for allocation of spill registers.
+     If we use round-robin, the reload pass allocates Y and Z registers
+     which are expensive compared to X and D.  */
+  last_spill_reg = -1;
+#endif
+  
   CLEAR_HARD_REG_SET (reg_used_in_insn);
   {
     HARD_REG_SET tmp;
@@ -6037,6 +6045,29 @@ deallocate_reload_reg (r)
   reload_spill_index[r] = -1;
 }
 
+
+/* Returns true if merging reloads i and j should result in a
+   RELOAD_FOR_OTHER_ADDRESS reload, else false for RELOAD_OTHER.  */
+static int
+merge_becomes_other_address (int i, int j)
+{
+  int wn1 = rld[i].when_needed;
+  int wn2 = rld[j].when_needed;
+
+  if (wn2 == RELOAD_FOR_OTHER_ADDRESS)
+    wn2 = wn1;
+  else if (wn1 != RELOAD_FOR_OTHER_ADDRESS)
+    return 0;
+
+  return (wn2 == RELOAD_FOR_INPUT_ADDRESS
+	  || wn2 == RELOAD_FOR_INPADDR_ADDRESS
+	  || wn2 == RELOAD_FOR_OUTPUT_ADDRESS
+	  || wn2 == RELOAD_FOR_OUTADDR_ADDRESS
+	  || wn2 == RELOAD_FOR_OPERAND_ADDRESS
+	  || wn2 == RELOAD_FOR_OPADDR_ADDR
+	  || wn2 == RELOAD_FOR_OTHER_ADDRESS);
+}
+
 /* If SMALL_REGISTER_CLASSES is nonzero, we may not have merged two
    reloads of the same item for fear that we might not have enough reload
    registers. However, normally they will get the same reload register
@@ -6050,6 +6081,7 @@ deallocate_reload_reg (r)
    This will not increase the number of spill registers needed and will
    prevent redundant code.  */
 
+extern const char *const reload_when_needed_name[];
 static void
 merge_assigned_reloads (insn)
      rtx insn;
@@ -6114,6 +6146,7 @@ merge_assigned_reloads (insn)
       if (j == n_reloads
 	  && max_input_address_opnum <= min_conflicting_input_opnum)
 	{
+          int changed = 0;
 	  for (j = 0; j < n_reloads; j++)
 	    if (i != j && rld[j].reg_rtx != 0
 		&& rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)
@@ -6121,12 +6154,22 @@ merge_assigned_reloads (insn)
 		    || rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS
 		    || rld[j].when_needed == RELOAD_FOR_OTHER_ADDRESS))
 	      {
-		rld[i].when_needed = RELOAD_OTHER;
+ 		if (merge_becomes_other_address (i, j))
+ 		  rld[i].when_needed = RELOAD_FOR_OTHER_ADDRESS;
+ 		else
+ 		  rld[i].when_needed = RELOAD_OTHER;
 		rld[j].in = 0;
 		reload_spill_index[j] = -1;
 		transfer_replacements (i, j);
+                changed = 1;
 	      }
 
+ 	  /* If this is now RELOAD_OTHER or RELOAD_FOR_OTHER_ADDRESS,
+ 	     look for any reloads that load parts of this operand and
+ 	     set them to RELOAD_FOR_OTHER_ADDRESS if they were for
+ 	     inputs, RELOAD_OTHER for outputs.  Note that this test is
+ 	     equivalent to looking for reloads for this operand
+  	     number.  */
 	  /* If this is now RELOAD_OTHER, look for any reloads that load
 	     parts of this operand and set them to RELOAD_FOR_OTHER_ADDRESS
 	     if they were for inputs, RELOAD_OTHER for outputs.  Note that
@@ -6137,7 +6180,9 @@ merge_assigned_reloads (insn)
 	     same value or a part of it; we must not change its type if there
 	     is a conflicting input.  */
 
-	  if (rld[i].when_needed == RELOAD_OTHER)
+ 	  if (changed
+              && (rld[i].when_needed == RELOAD_OTHER
+ 	          || rld[i].when_needed == RELOAD_FOR_OTHER_ADDRESS))
 	    for (j = 0; j < n_reloads; j++)
 	      if (rld[j].in != 0
 		  && rld[j].when_needed != RELOAD_OTHER
@@ -6152,7 +6197,8 @@ merge_assigned_reloads (insn)
 
 		  rld[j].when_needed
 		    = ((rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS
-			|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS)
+			|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS
+                        || rld[j].when_needed == RELOAD_FOR_OPADDR_ADDR)
 		       ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);
 
 		  /* Check to see if we accidentally converted two reloads
@@ -6164,8 +6210,13 @@ merge_assigned_reloads (insn)
 		      if (rld[k].in != 0 && rld[k].reg_rtx != 0
 			  && rld[k].when_needed == rld[j].when_needed
 			  && rtx_equal_p (rld[k].reg_rtx, rld[j].reg_rtx)
-			  && ! rtx_equal_p (rld[k].in, rld[j].in))
+			  && ! rtx_equal_p (rld[k].in, rld[j].in)) {
+                        printf("Changed reload %d, conflict %d with %d\n",
+                               i, k, j);
+                        
 			abort ();
+                      }
+                  
 		}
 	}
     }
@@ -7306,6 +7357,13 @@ emit_reload_insns (chain)
 					      rld[r].when_needed))
 		  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);
 	    }
+          else
+            {
+              /* When the reload does not reach the end, we must
+                 invalidate the old info.  */
+              for (k = 0; k < nr; k++)
+                CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);
+            }
 	}
 
       /* The following if-statement was #if 0'd in 1.34 (or before...).
diff -rupN gcc-3.3.6/gcc/reload.c gcc-3.3.6-s12x/gcc/reload.c
--- gcc-3.3.6/gcc/reload.c	2016-12-11 19:32:34.758648555 +0100
+++ gcc-3.3.6-s12x/gcc/reload.c	2016-12-11 19:32:40.978703658 +0100
@@ -4216,6 +4216,20 @@ find_reloads (insn, replace, ind_levels,
 
       if (goal_alternative_matches[rld[i].opnum] >= 0)
 	rld[i].opnum = goal_alternative_matches[rld[i].opnum];
+
+      /* If an operand's reload is RELOAD_OTHER, change any
+         RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_OUTPUT_ADDRESS reloads
+         of that operand to RELOAD_FOR_OTHER_ADDRESS.  This is necessary
+         to make sure the reloads are emitted in the good order.  We only need
+         to scan backward.  */
+      if (rld[i].when_needed == RELOAD_OTHER
+          && rld[i].optional == 0)
+        {
+          for (j = i - 1; j >= 0; j--)
+            if (rld[j].opnum == rld[i].opnum
+                && rld[j].when_needed == RELOAD_FOR_OPERAND_ADDRESS)
+              rld[j].when_needed = RELOAD_FOR_OTHER_ADDRESS;
+        }
     }
 
   /* Scan all the reloads, and check for RELOAD_FOR_OPERAND_ADDRESS reloads.
@@ -4556,10 +4570,8 @@ find_reloads_toplev (x, opnum, type, ind
 	 force a reload in that case.  So we should not do anything here.  */
 
       else if (regno >= FIRST_PSEUDO_REGISTER
-#ifdef LOAD_EXTEND_OP
 	       && (GET_MODE_SIZE (GET_MODE (x))
 		   <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))
-#endif
 	       && (reg_equiv_address[regno] != 0
 		   || (reg_equiv_mem[regno] != 0
 		       && (! strict_memory_address_p (GET_MODE (x),
@@ -5913,7 +5925,7 @@ find_reloads_subreg_address (x, force_re
 		}
 
 	      find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),
-				    &XEXP (tem, 0), opnum, ADDR_TYPE (type),
+				    &XEXP (tem, 0), opnum, type,
 				    ind_levels, insn);
 
 	      /* If this is not a toplevel operand, find_reloads doesn't see
diff -rupN gcc-3.3.6/gcc/toplev.c gcc-3.3.6-s12x/gcc/toplev.c
--- gcc-3.3.6/gcc/toplev.c	2016-12-11 19:32:34.770648662 +0100
+++ gcc-3.3.6-s12x/gcc/toplev.c	2016-12-11 19:32:40.998703835 +0100
@@ -3101,7 +3101,10 @@ rest_of_compilation (decl)
 	setjmp_args_warning ();
     }
 
-  if (optimize)
+  /* SCz: PR target/5854, this is initializing registers by inserting
+     instructions before the prologue instructions that save incomming
+     registers.  */
+  if (optimize && 0)
     {
       if (!flag_new_regalloc && initialize_uninitialized_subregs ())
 	{
diff -rupN gcc-3.3.6/gcc/version.c gcc-3.3.6-s12x/gcc/version.c
--- gcc-3.3.6/gcc/version.c	2016-12-11 19:32:34.770648662 +0100
+++ gcc-3.3.6-s12x/gcc/version.c	2016-12-11 19:32:40.998703835 +0100
@@ -6,7 +6,7 @@
    please modify this string to indicate that, e.g. by putting your
    organization's name in parentheses at the end of the string.  */
 
-const char version_string[] = "3.3.6";
+const char version_string[] = "3.3.6-9s12x-20120502";
 
 /* This is the location of the online document giving instructions for
    reporting bugs.  If you distribute a modified version of GCC,
